<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>bpf - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../../../../lib/godoc/style.css">


<script>window.initFuncs = [];</script>

<script src="../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.11.5";</script>
<script src="../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/">Go</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">
<a href="http://localhost:6060/doc/">Documents</a>
<a href="../../../../index.html">Packages</a>
<a href="http://localhost:6060/project/">The Project</a>
<a href="http://localhost:6060/help/">Help</a>

<a href="http://localhost:6060/blog/">Blog</a>


<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package bpf
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/net/bpf"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package bpf implements marshaling and unmarshaling of programs for the
Berkeley Packet Filter virtual machine, and provides a Go implementation
of the virtual machine.
</p>
<p>
BPF&#39;s main use is to specify a packet filter for network taps, so that
the kernel doesn&#39;t have to expensively copy every packet it sees to
userspace. However, it&#39;s been repurposed to other areas where running
user code in-kernel is needed. For example, Linux&#39;s seccomp uses BPF
to apply security policies to system calls. For simplicity, this
documentation refers only to packets, but other uses of BPF have their
own data payloads.
</p>
<p>
BPF programs run in a restricted virtual machine. It has almost no
access to kernel functions, and while conditional branches are
allowed, they can only jump forwards, to guarantee that there are no
infinite loops.
</p>
<h3 id="hdr-The_virtual_machine">The virtual machine</h3>
<p>
The BPF VM is an accumulator machine. Its main register, called
register A, is an implicit source and destination in all arithmetic
and logic operations. The machine also has 16 scratch registers for
temporary storage, and an indirection register (register X) for
indirect memory access. All registers are 32 bits wide.
</p>
<p>
Each run of a BPF program is given one packet, which is placed in the
VM&#39;s read-only &#34;main memory&#34;. LoadAbsolute and LoadIndirect
instructions can fetch up to 32 bits at a time into register A for
examination.
</p>
<p>
The goal of a BPF program is to produce and return a verdict (uint32),
which tells the kernel what to do with the packet. In the context of
packet filtering, the returned value is the number of bytes of the
packet to forward to userspace, or 0 to ignore the packet. Other
contexts like seccomp define their own return values.
</p>
<p>
In order to simplify programs, attempts to read past the end of the
packet terminate the program execution with a verdict of 0 (ignore
packet). This means that the vast majority of BPF programs don&#39;t need
to do any explicit bounds checking.
</p>
<p>
In addition to the bytes of the packet, some BPF programs have access
to extensions, which are essentially calls to kernel utility
functions. Currently, the only extensions supported by this package
are the Linux packet filter extensions.
</p>
<h3 id="hdr-Examples">Examples</h3>
<p>
This packet filter selects all ARP packets.
</p>
<pre>bpf.Assemble([]bpf.Instruction{
	// Load &#34;EtherType&#34; field from the ethernet header.
	bpf.LoadAbsolute{Off: 12, Size: 2},
	// Skip over the next instruction if EtherType is not ARP.
	bpf.JumpIf{Cond: bpf.JumpNotEqual, Val: 0x0806, SkipTrue: 1},
	// Verdict is &#34;send up to 4k of the packet to userspace.&#34;
	bpf.RetConstant{Val: 4096},
	// Verdict is &#34;ignore packet.&#34;
	bpf.RetConstant{Val: 0},
})
</pre>
<p>
This packet filter captures a random 1% sample of traffic.
</p>
<pre>bpf.Assemble([]bpf.Instruction{
	// Get a 32-bit random number from the Linux kernel.
	bpf.LoadExtension{Num: bpf.ExtRand},
	// 1% dice roll?
	bpf.JumpIf{Cond: bpf.JumpLessThan, Val: 2^32/100, SkipFalse: 1},
	// Capture.
	bpf.RetConstant{Val: 4096},
	// Ignore.
	bpf.RetConstant{Val: 0},
})
</pre>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
			
				
				<dd><a href="index.html#ALUOp">type ALUOp</a></dd>
				
				
			
				
				<dd><a href="index.html#ALUOpConstant">type ALUOpConstant</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ALUOpConstant.Assemble">func (a ALUOpConstant) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ALUOpConstant.String">func (a ALUOpConstant) String() string</a></dd>
				
			
				
				<dd><a href="index.html#ALUOpX">type ALUOpX</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ALUOpX.Assemble">func (a ALUOpX) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ALUOpX.String">func (a ALUOpX) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Extension">type Extension</a></dd>
				
				
			
				
				<dd><a href="index.html#Instruction">type Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Disassemble">func Disassemble(raw []RawInstruction) (insts []Instruction, allDecoded bool)</a></dd>
				
				
			
				
				<dd><a href="index.html#Jump">type Jump</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.Assemble">func (a Jump) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Jump.String">func (a Jump) String() string</a></dd>
				
			
				
				<dd><a href="index.html#JumpIf">type JumpIf</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#JumpIf.Assemble">func (a JumpIf) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#JumpIf.String">func (a JumpIf) String() string</a></dd>
				
			
				
				<dd><a href="index.html#JumpIfX">type JumpIfX</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#JumpIfX.Assemble">func (a JumpIfX) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#JumpIfX.String">func (a JumpIfX) String() string</a></dd>
				
			
				
				<dd><a href="index.html#JumpTest">type JumpTest</a></dd>
				
				
			
				
				<dd><a href="index.html#LoadAbsolute">type LoadAbsolute</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadAbsolute.Assemble">func (a LoadAbsolute) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadAbsolute.String">func (a LoadAbsolute) String() string</a></dd>
				
			
				
				<dd><a href="index.html#LoadConstant">type LoadConstant</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadConstant.Assemble">func (a LoadConstant) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadConstant.String">func (a LoadConstant) String() string</a></dd>
				
			
				
				<dd><a href="index.html#LoadExtension">type LoadExtension</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadExtension.Assemble">func (a LoadExtension) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadExtension.String">func (a LoadExtension) String() string</a></dd>
				
			
				
				<dd><a href="index.html#LoadIndirect">type LoadIndirect</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadIndirect.Assemble">func (a LoadIndirect) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadIndirect.String">func (a LoadIndirect) String() string</a></dd>
				
			
				
				<dd><a href="index.html#LoadMemShift">type LoadMemShift</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadMemShift.Assemble">func (a LoadMemShift) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadMemShift.String">func (a LoadMemShift) String() string</a></dd>
				
			
				
				<dd><a href="index.html#LoadScratch">type LoadScratch</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadScratch.Assemble">func (a LoadScratch) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#LoadScratch.String">func (a LoadScratch) String() string</a></dd>
				
			
				
				<dd><a href="index.html#NegateA">type NegateA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NegateA.Assemble">func (a NegateA) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NegateA.String">func (a NegateA) String() string</a></dd>
				
			
				
				<dd><a href="index.html#RawInstruction">type RawInstruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Assemble">func Assemble(insts []Instruction) ([]RawInstruction, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawInstruction.Assemble">func (ri RawInstruction) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawInstruction.Disassemble">func (ri RawInstruction) Disassemble() Instruction</a></dd>
				
			
				
				<dd><a href="index.html#Register">type Register</a></dd>
				
				
			
				
				<dd><a href="index.html#RetA">type RetA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RetA.Assemble">func (a RetA) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RetA.String">func (a RetA) String() string</a></dd>
				
			
				
				<dd><a href="index.html#RetConstant">type RetConstant</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RetConstant.Assemble">func (a RetConstant) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RetConstant.String">func (a RetConstant) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Setter">type Setter</a></dd>
				
				
			
				
				<dd><a href="index.html#StoreScratch">type StoreScratch</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#StoreScratch.Assemble">func (a StoreScratch) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#StoreScratch.String">func (a StoreScratch) String() string</a></dd>
				
			
				
				<dd><a href="index.html#TAX">type TAX</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TAX.Assemble">func (a TAX) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TAX.String">func (a TAX) String() string</a></dd>
				
			
				
				<dd><a href="index.html#TXA">type TXA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TXA.Assemble">func (a TXA) Assemble() (RawInstruction, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#TXA.String">func (a TXA) String() string</a></dd>
				
			
				
				<dd><a href="index.html#VM">type VM</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewVM">func NewVM(filter []Instruction) (*VM, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#VM.Run">func (v *VM) Run(in []byte) (int, error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_NewVM">NewVM</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/asm.go">asm.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/constants.go">constants.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go">instructions.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/setter.go">setter.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/vm.go">vm.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/bpf/vm_instructions.go">vm_instructions.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
		
			
			
			<h2 id="ALUOp">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/constants.go?s=515:532#L10">ALUOp</a>
				<a class="permalink" href="index.html#ALUOp">&#xb6;</a>
				
				
			</h2>
			<p>
An ALUOp is an arithmetic or logic operation.
</p>

			<pre>type ALUOp <a href="http://localhost:6060/pkg/builtin/#uint16">uint16</a></pre>

			
				<p>
ALU binary operation types.
</p>

				<pre>const (
    <span id="ALUOpAdd">ALUOpAdd</span> <a href="index.html#ALUOp">ALUOp</a> = <a href="http://localhost:6060/pkg/builtin/#iota">iota</a> &lt;&lt; 4
    <span id="ALUOpSub">ALUOpSub</span>
    <span id="ALUOpMul">ALUOpMul</span>
    <span id="ALUOpDiv">ALUOpDiv</span>
    <span id="ALUOpOr">ALUOpOr</span>
    <span id="ALUOpAnd">ALUOpAnd</span>
    <span id="ALUOpShiftLeft">ALUOpShiftLeft</span>
    <span id="ALUOpShiftRight">ALUOpShiftRight</span>

    <span id="ALUOpMod">ALUOpMod</span>
    <span id="ALUOpXor">ALUOpXor</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="ALUOpConstant">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=9995:10047#L392">ALUOpConstant</a>
				<a class="permalink" href="index.html#ALUOpConstant">&#xb6;</a>
				
				
			</h2>
			<p>
ALUOpConstant executes A = A &lt;Op&gt; Val.
</p>

			<pre>type ALUOpConstant struct {
<span id="ALUOpConstant.Op"></span>    Op  <a href="index.html#ALUOp">ALUOp</a>
<span id="ALUOpConstant.Val"></span>    Val <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ALUOpConstant.Assemble">func (ALUOpConstant) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=10105:10162#L398">Assemble</a>
					<a class="permalink" href="index.html#ALUOpConstant.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#ALUOpConstant">ALUOpConstant</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="ALUOpConstant.String">func (ALUOpConstant) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=10329:10367#L406">String</a>
					<a class="permalink" href="index.html#ALUOpConstant.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#ALUOpConstant">ALUOpConstant</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="ALUOpX">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=11046:11078#L434">ALUOpX</a>
				<a class="permalink" href="index.html#ALUOpX">&#xb6;</a>
				
				
			</h2>
			<p>
ALUOpX executes A = A &lt;Op&gt; X
</p>

			<pre>type ALUOpX struct {
<span id="ALUOpX.Op"></span>    Op <a href="index.html#ALUOp">ALUOp</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ALUOpX.Assemble">func (ALUOpX) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=11136:11186#L439">Assemble</a>
					<a class="permalink" href="index.html#ALUOpX.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#ALUOpX">ALUOpX</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="ALUOpX.String">func (ALUOpX) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=11333:11364#L446">String</a>
					<a class="permalink" href="index.html#ALUOpX.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#ALUOpX">ALUOpX</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="Extension">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/constants.go?s=1619:1637#L60">Extension</a>
				<a class="permalink" href="index.html#Extension">&#xb6;</a>
				
				
			</h2>
			<p>
An Extension is a function call provided by the kernel that
performs advanced operations that are expensive or impossible
within the BPF virtual machine.
</p>
<p>
Extensions are only implemented by the Linux kernel.
</p>
<p>
TODO: should we prune this list? Some of these extensions seem
either broken or near-impossible to use correctly, whereas other
(len, random, ifindex) are quite useful.
</p>

			<pre>type Extension <a href="http://localhost:6060/pkg/builtin/#int">int</a></pre>

			
				<p>
Extension functions available in the Linux kernel.
</p>

				<pre>const (

    <span class="comment">// ExtLen returns the length of the packet.</span>
    <span id="ExtLen">ExtLen</span> <a href="index.html#Extension">Extension</a> = 1
    <span class="comment">// ExtProto returns the packet&#39;s L3 protocol type.</span>
    <span id="ExtProto">ExtProto</span> <a href="index.html#Extension">Extension</a> = 0
    <span class="comment">// ExtType returns the packet&#39;s type (skb-&gt;pkt_type in the kernel)</span>
    <span class="comment">//</span>
    <span class="comment">// TODO: better documentation. How nice an API do we want to</span>
    <span class="comment">// provide for these esoteric extensions?</span>
    <span id="ExtType">ExtType</span> <a href="index.html#Extension">Extension</a> = 4
    <span class="comment">// ExtPayloadOffset returns the offset of the packet payload, or</span>
    <span class="comment">// the first protocol header that the kernel does not know how to</span>
    <span class="comment">// parse.</span>
    <span id="ExtPayloadOffset">ExtPayloadOffset</span> <a href="index.html#Extension">Extension</a> = 52
    <span class="comment">// ExtInterfaceIndex returns the index of the interface on which</span>
    <span class="comment">// the packet was received.</span>
    <span id="ExtInterfaceIndex">ExtInterfaceIndex</span> <a href="index.html#Extension">Extension</a> = 8
    <span class="comment">// ExtNetlinkAttr returns the netlink attribute of type X at</span>
    <span class="comment">// offset A.</span>
    <span id="ExtNetlinkAttr">ExtNetlinkAttr</span> <a href="index.html#Extension">Extension</a> = 12
    <span class="comment">// ExtNetlinkAttrNested returns the nested netlink attribute of</span>
    <span class="comment">// type X at offset A.</span>
    <span id="ExtNetlinkAttrNested">ExtNetlinkAttrNested</span> <a href="index.html#Extension">Extension</a> = 16
    <span class="comment">// ExtMark returns the packet&#39;s mark value.</span>
    <span id="ExtMark">ExtMark</span> <a href="index.html#Extension">Extension</a> = 20
    <span class="comment">// ExtQueue returns the packet&#39;s assigned hardware queue.</span>
    <span id="ExtQueue">ExtQueue</span> <a href="index.html#Extension">Extension</a> = 24
    <span class="comment">// ExtLinkLayerType returns the packet&#39;s hardware address type</span>
    <span class="comment">// (e.g. Ethernet, Infiniband).</span>
    <span id="ExtLinkLayerType">ExtLinkLayerType</span> <a href="index.html#Extension">Extension</a> = 28
    <span class="comment">// ExtRXHash returns the packets receive hash.</span>
    <span class="comment">//</span>
    <span class="comment">// TODO: figure out what this rxhash actually is.</span>
    <span id="ExtRXHash">ExtRXHash</span> <a href="index.html#Extension">Extension</a> = 32
    <span class="comment">// ExtCPUID returns the ID of the CPU processing the current</span>
    <span class="comment">// packet.</span>
    <span id="ExtCPUID">ExtCPUID</span> <a href="index.html#Extension">Extension</a> = 36
    <span class="comment">// ExtVLANTag returns the packet&#39;s VLAN tag.</span>
    <span id="ExtVLANTag">ExtVLANTag</span> <a href="index.html#Extension">Extension</a> = 44
    <span class="comment">// ExtVLANTagPresent returns non-zero if the packet has a VLAN</span>
    <span class="comment">// tag.</span>
    <span class="comment">//</span>
    <span class="comment">// TODO: I think this might be a lie: it reads bit 0x1000 of the</span>
    <span class="comment">// VLAN header, which changed meaning in recent revisions of the</span>
    <span class="comment">// spec - this extension may now return meaningless information.</span>
    <span id="ExtVLANTagPresent">ExtVLANTagPresent</span> <a href="index.html#Extension">Extension</a> = 48
    <span class="comment">// ExtVLANProto returns 0x8100 if the frame has a VLAN header,</span>
    <span class="comment">// 0x88a8 if the frame has a &#34;Q-in-Q&#34; double VLAN header, or some</span>
    <span class="comment">// other value if no VLAN information is present.</span>
    <span id="ExtVLANProto">ExtVLANProto</span> <a href="index.html#Extension">Extension</a> = 60
    <span class="comment">// ExtRand returns a uniformly random uint32.</span>
    <span id="ExtRand">ExtRand</span> <a href="index.html#Extension">Extension</a> = 56
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Instruction">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=264:392#L1">Instruction</a>
				<a class="permalink" href="index.html#Instruction">&#xb6;</a>
				
				
			</h2>
			<p>
An Instruction is one instruction executed by the BPF virtual
machine.
</p>

			<pre>type Instruction interface {
    <span class="comment">// Assemble assembles the Instruction into a RawInstruction.</span>
    Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)
}</pre>

			

			

			
			
			

			
				
				<h3 id="Disassemble">func <a href="http://localhost:6060/src/golang.org/x/net/bpf/asm.go?s=972:1049#L21">Disassemble</a>
					<a class="permalink" href="index.html#Disassemble">&#xb6;</a>
					
					
				</h3>
				<pre>func Disassemble(raw []<a href="index.html#RawInstruction">RawInstruction</a>) (insts []<a href="index.html#Instruction">Instruction</a>, allDecoded <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Disassemble attempts to parse raw back into
Instructions. Unrecognized RawInstructions are assumed to be an
extension not implemented by this package, and are passed through
unchanged to the output. The allDecoded value reports whether insts
contains no RawInstructions.
</p>

				
				
			

			
		
			
			
			<h2 id="Jump">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12206:12239#L489">Jump</a>
				<a class="permalink" href="index.html#Jump">&#xb6;</a>
				
				
			</h2>
			<p>
Jump skips the following Skip instructions in the program.
</p>

			<pre>type Jump struct {
<span id="Jump.Skip"></span>    Skip <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Jump.Assemble">func (Jump) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12297:12345#L494">Assemble</a>
					<a class="permalink" href="index.html#Jump.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Jump">Jump</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="Jump.String">func (Jump) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12494:12523#L502">String</a>
					<a class="permalink" href="index.html#Jump.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#Jump">Jump</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="JumpIf">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12657:12751#L508">JumpIf</a>
				<a class="permalink" href="index.html#JumpIf">&#xb6;</a>
				
				
			</h2>
			<p>
JumpIf skips the following Skip instructions in the program if A
&lt;Cond&gt; Val is true.
</p>

			<pre>type JumpIf struct {
<span id="JumpIf.Cond"></span>    Cond      <a href="index.html#JumpTest">JumpTest</a>
<span id="JumpIf.Val"></span>    Val       <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
<span id="JumpIf.SkipTrue"></span>    SkipTrue  <a href="http://localhost:6060/pkg/builtin/#uint8">uint8</a>
<span id="JumpIf.SkipFalse"></span>    SkipFalse <a href="http://localhost:6060/pkg/builtin/#uint8">uint8</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="JumpIf.Assemble">func (JumpIf) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12809:12859#L516">Assemble</a>
					<a class="permalink" href="index.html#JumpIf.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#JumpIf">JumpIf</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="JumpIf.String">func (JumpIf) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12999:13030#L521">String</a>
					<a class="permalink" href="index.html#JumpIf.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#JumpIf">JumpIf</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="JumpIfX">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=13207:13284#L527">JumpIfX</a>
				<a class="permalink" href="index.html#JumpIfX">&#xb6;</a>
				
				
			</h2>
			<p>
JumpIfX skips the following Skip instructions in the program if A
&lt;Cond&gt; X is true.
</p>

			<pre>type JumpIfX struct {
<span id="JumpIfX.Cond"></span>    Cond      <a href="index.html#JumpTest">JumpTest</a>
<span id="JumpIfX.SkipTrue"></span>    SkipTrue  <a href="http://localhost:6060/pkg/builtin/#uint8">uint8</a>
<span id="JumpIfX.SkipFalse"></span>    SkipFalse <a href="http://localhost:6060/pkg/builtin/#uint8">uint8</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="JumpIfX.Assemble">func (JumpIfX) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=13342:13393#L534">Assemble</a>
					<a class="permalink" href="index.html#JumpIfX.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#JumpIfX">JumpIfX</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="JumpIfX.String">func (JumpIfX) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=13522:13554#L539">String</a>
					<a class="permalink" href="index.html#JumpIfX.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#JumpIfX">JumpIfX</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="JumpTest">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/constants.go?s=876:896#L28">JumpTest</a>
				<a class="permalink" href="index.html#JumpTest">&#xb6;</a>
				
				
			</h2>
			<p>
A JumpTest is a comparison operator used in conditional jumps.
</p>

			<pre>type JumpTest <a href="http://localhost:6060/pkg/builtin/#uint16">uint16</a></pre>

			
				<p>
Supported operators for conditional jumps.
K can be RegX for JumpIfX
</p>

				<pre>const (
    <span class="comment">// K == A</span>
    <span id="JumpEqual">JumpEqual</span> <a href="index.html#JumpTest">JumpTest</a> = <a href="http://localhost:6060/pkg/builtin/#iota">iota</a>
    <span class="comment">// K != A</span>
    <span id="JumpNotEqual">JumpNotEqual</span>
    <span class="comment">// K &gt; A</span>
    <span id="JumpGreaterThan">JumpGreaterThan</span>
    <span class="comment">// K &lt; A</span>
    <span id="JumpLessThan">JumpLessThan</span>
    <span class="comment">// K &gt;= A</span>
    <span id="JumpGreaterOrEqual">JumpGreaterOrEqual</span>
    <span class="comment">// K &lt;= A</span>
    <span id="JumpLessOrEqual">JumpLessOrEqual</span>
    <span class="comment">// K &amp; A != 0</span>
    <span id="JumpBitsSet">JumpBitsSet</span>
    <span class="comment">// K &amp; A == 0</span>
    <span id="JumpBitsNotSet">JumpBitsNotSet</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="LoadAbsolute">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=5768:5832#L225">LoadAbsolute</a>
				<a class="permalink" href="index.html#LoadAbsolute">&#xb6;</a>
				
				
			</h2>
			<p>
LoadAbsolute loads packet[Off:Off+Size] as an integer value into
register A.
</p>

			<pre>type LoadAbsolute struct {
<span id="LoadAbsolute.Off"></span>    Off  <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
<span id="LoadAbsolute.Size"></span>    Size <a href="http://localhost:6060/pkg/builtin/#int">int</a> <span class="comment">// 1, 2 or 4</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LoadAbsolute.Assemble">func (LoadAbsolute) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=5890:5946#L231">Assemble</a>
					<a class="permalink" href="index.html#LoadAbsolute.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadAbsolute">LoadAbsolute</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="LoadAbsolute.String">func (LoadAbsolute) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=6071:6108#L236">String</a>
					<a class="permalink" href="index.html#LoadAbsolute.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadAbsolute">LoadAbsolute</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="LoadConstant">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=4499:4553#L175">LoadConstant</a>
				<a class="permalink" href="index.html#LoadConstant">&#xb6;</a>
				
				
			</h2>
			<p>
LoadConstant loads Val into register Dst.
</p>

			<pre>type LoadConstant struct {
<span id="LoadConstant.Dst"></span>    Dst <a href="index.html#Register">Register</a>
<span id="LoadConstant.Val"></span>    Val <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LoadConstant.Assemble">func (LoadConstant) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=4611:4667#L181">Assemble</a>
					<a class="permalink" href="index.html#LoadConstant.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadConstant">LoadConstant</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="LoadConstant.String">func (LoadConstant) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=4789:4826#L186">String</a>
					<a class="permalink" href="index.html#LoadConstant.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadConstant">LoadConstant</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="LoadExtension">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=7946:7990#L300">LoadExtension</a>
				<a class="permalink" href="index.html#LoadExtension">&#xb6;</a>
				
				
			</h2>
			<p>
LoadExtension invokes a linux-specific extension and stores the
result in register A.
</p>

			<pre>type LoadExtension struct {
<span id="LoadExtension.Num"></span>    Num <a href="index.html#Extension">Extension</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LoadExtension.Assemble">func (LoadExtension) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=8048:8105#L305">Assemble</a>
					<a class="permalink" href="index.html#LoadExtension.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadExtension">LoadExtension</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="LoadExtension.String">func (LoadExtension) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=8323:8361#L313">String</a>
					<a class="permalink" href="index.html#LoadExtension.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadExtension">LoadExtension</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="LoadIndirect">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=6563:6627#L254">LoadIndirect</a>
				<a class="permalink" href="index.html#LoadIndirect">&#xb6;</a>
				
				
			</h2>
			<p>
LoadIndirect loads packet[X+Off:X+Off+Size] as an integer value
into register A.
</p>

			<pre>type LoadIndirect struct {
<span id="LoadIndirect.Off"></span>    Off  <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
<span id="LoadIndirect.Size"></span>    Size <a href="http://localhost:6060/pkg/builtin/#int">int</a> <span class="comment">// 1, 2 or 4</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LoadIndirect.Assemble">func (LoadIndirect) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=6685:6741#L260">Assemble</a>
					<a class="permalink" href="index.html#LoadIndirect.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadIndirect">LoadIndirect</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="LoadIndirect.String">func (LoadIndirect) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=6866:6903#L265">String</a>
					<a class="permalink" href="index.html#LoadIndirect.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadIndirect">LoadIndirect</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="LoadMemShift">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=7490:7530#L284">LoadMemShift</a>
				<a class="permalink" href="index.html#LoadMemShift">&#xb6;</a>
				
				
			</h2>
			<p>
LoadMemShift multiplies the first 4 bits of the byte at packet[Off]
by 4 and stores the result in register X.
</p>
<p>
This instruction is mainly useful to load into X the length of an
IPv4 packet header in a single instruction, rather than have to do
the arithmetic on the header&#39;s first byte by hand.
</p>

			<pre>type LoadMemShift struct {
<span id="LoadMemShift.Off"></span>    Off <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LoadMemShift.Assemble">func (LoadMemShift) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=7588:7644#L289">Assemble</a>
					<a class="permalink" href="index.html#LoadMemShift.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadMemShift">LoadMemShift</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="LoadMemShift.String">func (LoadMemShift) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=7764:7801#L294">String</a>
					<a class="permalink" href="index.html#LoadMemShift.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadMemShift">LoadMemShift</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="LoadScratch">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=5065:5123#L198">LoadScratch</a>
				<a class="permalink" href="index.html#LoadScratch">&#xb6;</a>
				
				
			</h2>
			<p>
LoadScratch loads scratch[N] into register Dst.
</p>

			<pre>type LoadScratch struct {
<span id="LoadScratch.Dst"></span>    Dst <a href="index.html#Register">Register</a>
<span id="LoadScratch.N"></span>    N   <a href="http://localhost:6060/pkg/builtin/#int">int</a> <span class="comment">// 0-15</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="LoadScratch.Assemble">func (LoadScratch) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=5181:5236#L204">Assemble</a>
					<a class="permalink" href="index.html#LoadScratch.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadScratch">LoadScratch</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="LoadScratch.String">func (LoadScratch) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=5461:5497#L212">String</a>
					<a class="permalink" href="index.html#LoadScratch.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#LoadScratch">LoadScratch</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="NegateA">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=11819:11840#L474">NegateA</a>
				<a class="permalink" href="index.html#NegateA">&#xb6;</a>
				
				
			</h2>
			<p>
NegateA executes A = -A.
</p>

			<pre>type NegateA struct{}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NegateA.Assemble">func (NegateA) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=11898:11949#L477">Assemble</a>
					<a class="permalink" href="index.html#NegateA.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#NegateA">NegateA</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="NegateA.String">func (NegateA) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=12079:12111#L484">String</a>
					<a class="permalink" href="index.html#NegateA.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#NegateA">NegateA</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="RawInstruction">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=456:718#L7">RawInstruction</a>
				<a class="permalink" href="index.html#RawInstruction">&#xb6;</a>
				
				
			</h2>
			<p>
A RawInstruction is a raw BPF virtual machine instruction.
</p>

			<pre>type RawInstruction struct {
    <span class="comment">// Operation to execute.</span>
<span id="RawInstruction.Op"></span>    Op <a href="http://localhost:6060/pkg/builtin/#uint16">uint16</a>
    <span class="comment">// For conditional jump instructions, the number of instructions</span>
    <span class="comment">// to skip if the condition is true/false.</span>
<span id="RawInstruction.Jt"></span>    Jt <a href="http://localhost:6060/pkg/builtin/#uint8">uint8</a>
<span id="RawInstruction.Jf"></span>    Jf <a href="http://localhost:6060/pkg/builtin/#uint8">uint8</a>
    <span class="comment">// Constant parameter. The meaning depends on the Op.</span>
<span id="RawInstruction.K"></span>    K <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Assemble">func <a href="http://localhost:6060/src/golang.org/x/net/bpf/asm.go?s=389:449#L4">Assemble</a>
					<a class="permalink" href="index.html#Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func Assemble(insts []<a href="index.html#Instruction">Instruction</a>) ([]<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble converts insts into raw instructions suitable for loading
into a BPF virtual machine.
</p>
<p>
Currently, no optimization is attempted, the assembled program flow
is exactly as provided.
</p>

				
				
			

			
				
				<h3 id="RawInstruction.Assemble">func (RawInstruction) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=776:835#L19">Assemble</a>
					<a class="permalink" href="index.html#RawInstruction.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (ri <a href="index.html#RawInstruction">RawInstruction</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="RawInstruction.Disassemble">func (RawInstruction) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=984:1034#L23">Disassemble</a>
					<a class="permalink" href="index.html#RawInstruction.Disassemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (ri <a href="index.html#RawInstruction">RawInstruction</a>) Disassemble() <a href="index.html#Instruction">Instruction</a></pre>
				<p>
Disassemble parses ri into an Instruction and returns it. If ri is
not recognized by this package, ri itself is returned.
</p>

				
				
				
			
		
			
			
			<h2 id="Register">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/constants.go?s=229:249#L1">Register</a>
				<a class="permalink" href="index.html#Register">&#xb6;</a>
				
				
			</h2>
			<p>
A Register is a register of the BPF virtual machine.
</p>

			<pre>type Register <a href="http://localhost:6060/pkg/builtin/#uint16">uint16</a></pre>

			
				
				<pre>const (
    <span class="comment">// RegA is the accumulator register. RegA is always the</span>
    <span class="comment">// destination register of ALU operations.</span>
    <span id="RegA">RegA</span> <a href="index.html#Register">Register</a> = <a href="http://localhost:6060/pkg/builtin/#iota">iota</a>
    <span class="comment">// RegX is the indirection register, used by LoadIndirect</span>
    <span class="comment">// operations.</span>
    <span id="RegX">RegX</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="RetA">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16074:16092#L627">RetA</a>
				<a class="permalink" href="index.html#RetA">&#xb6;</a>
				
				
			</h2>
			<p>
RetA exits the BPF program, returning the value of register A.
</p>

			<pre>type RetA struct{}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="RetA.Assemble">func (RetA) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16150:16198#L630">Assemble</a>
					<a class="permalink" href="index.html#RetA.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#RetA">RetA</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="RetA.String">func (RetA) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16324:16353#L637">String</a>
					<a class="permalink" href="index.html#RetA.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#RetA">RetA</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="RetConstant">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16454:16493#L642">RetConstant</a>
				<a class="permalink" href="index.html#RetConstant">&#xb6;</a>
				
				
			</h2>
			<p>
RetConstant exits the BPF program, returning a constant value.
</p>

			<pre>type RetConstant struct {
<span id="RetConstant.Val"></span>    Val <a href="http://localhost:6060/pkg/builtin/#uint32">uint32</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="RetConstant.Assemble">func (RetConstant) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16551:16606#L647">Assemble</a>
					<a class="permalink" href="index.html#RetConstant.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#RetConstant">RetConstant</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="RetConstant.String">func (RetConstant) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16752:16788#L655">String</a>
					<a class="permalink" href="index.html#RetConstant.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#RetConstant">RetConstant</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="Setter">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/setter.go?s=245:309#L1">Setter</a>
				<a class="permalink" href="index.html#Setter">&#xb6;</a>
				
				
			</h2>
			<p>
A Setter is a type which can attach a compiled BPF filter to itself.
</p>

			<pre>type Setter interface {
    SetBPF(filter []<a href="index.html#RawInstruction">RawInstruction</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="StoreScratch">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=9150:9209#L353">StoreScratch</a>
				<a class="permalink" href="index.html#StoreScratch">&#xb6;</a>
				
				
			</h2>
			<p>
StoreScratch stores register Src into scratch[N].
</p>

			<pre>type StoreScratch struct {
<span id="StoreScratch.Src"></span>    Src <a href="index.html#Register">Register</a>
<span id="StoreScratch.N"></span>    N   <a href="http://localhost:6060/pkg/builtin/#int">int</a> <span class="comment">// 0-15</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="StoreScratch.Assemble">func (StoreScratch) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=9267:9323#L359">Assemble</a>
					<a class="permalink" href="index.html#StoreScratch.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#StoreScratch">StoreScratch</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="StoreScratch.String">func (StoreScratch) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=9728:9765#L380">String</a>
					<a class="permalink" href="index.html#StoreScratch.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#StoreScratch">StoreScratch</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="TAX">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=17245:17262#L675">TAX</a>
				<a class="permalink" href="index.html#TAX">&#xb6;</a>
				
				
			</h2>
			<p>
TAX copies the value of register A to register X.
</p>

			<pre>type TAX struct{}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="TAX.Assemble">func (TAX) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=17320:17367#L678">Assemble</a>
					<a class="permalink" href="index.html#TAX.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#TAX">TAX</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="TAX.String">func (TAX) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=17491:17519#L685">String</a>
					<a class="permalink" href="index.html#TAX.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#TAX">TAX</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="TXA">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16885:16902#L660">TXA</a>
				<a class="permalink" href="index.html#TXA">&#xb6;</a>
				
				
			</h2>
			<p>
TXA copies the value of register X to register A.
</p>

			<pre>type TXA struct{}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="TXA.Assemble">func (TXA) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=16960:17007#L663">Assemble</a>
					<a class="permalink" href="index.html#TXA.Assemble">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#TXA">TXA</a>) Assemble() (<a href="index.html#RawInstruction">RawInstruction</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Assemble implements the Instruction Assemble method.
</p>

				
				
				
			
				
				<h3 id="TXA.String">func (TXA) <a href="http://localhost:6060/src/golang.org/x/net/bpf/instructions.go?s=17131:17159#L670">String</a>
					<a class="permalink" href="index.html#TXA.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="index.html#TXA">TXA</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				<p>
String returns the instruction in assembler notation.
</p>

				
				
				
			
		
			
			
			<h2 id="VM">type <a href="http://localhost:6060/src/golang.org/x/net/bpf/vm.go?s=246:286#L3">VM</a>
				<a class="permalink" href="index.html#VM">&#xb6;</a>
				
				
			</h2>
			<p>
A VM is an emulated BPF virtual machine.
</p>

			<pre>type VM struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewVM">func <a href="http://localhost:6060/src/golang.org/x/net/bpf/vm.go?s=343:388#L8">NewVM</a>
					<a class="permalink" href="index.html#NewVM">&#xb6;</a>
					
					
				</h3>
				<pre>func NewVM(filter []<a href="index.html#Instruction">Instruction</a>) (*<a href="index.html#VM">VM</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
NewVM returns a new VM using the input BPF program.
</p>

				<div id="example_NewVM" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleNewVM demonstrates usage of a VM, using an Ethernet frame
as input and checking its EtherType to determine if it should be accepted.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Offset | Length | Comment</span>
<span class="comment">// -------------------------</span>
<span class="comment">//   00   |   06   | Ethernet destination MAC address</span>
<span class="comment">//   06   |   06   | Ethernet source MAC address</span>
<span class="comment">//   12   |   02   | Ethernet EtherType</span>
const (
    etOff = 12
    etLen = 2

    etARP = 0x0806
)

<span class="comment">// Set up a VM to filter traffic based on if its EtherType</span>
<span class="comment">// matches the ARP EtherType.</span>
vm, err := bpf.NewVM([]bpf.Instruction{
    <span class="comment">// Load EtherType value from Ethernet header</span>
    bpf.LoadAbsolute{
        Off:  etOff,
        Size: etLen,
    },
    <span class="comment">// If EtherType is equal to the ARP EtherType, jump to allow</span>
    <span class="comment">// packet to be accepted</span>
    bpf.JumpIf{
        Cond:     bpf.JumpEqual,
        Val:      etARP,
        SkipTrue: 1,
    },
    <span class="comment">// EtherType does not match the ARP EtherType</span>
    bpf.RetConstant{
        Val: 0,
    },
    <span class="comment">// EtherType matches the ARP EtherType, accept up to 1500</span>
    <span class="comment">// bytes of packet</span>
    bpf.RetConstant{
        Val: 1500,
    },
})
if err != nil {
    panic(fmt.Sprintf(&#34;failed to load BPF program: %v&#34;, err))
}

<span class="comment">// Create an Ethernet frame with the ARP EtherType for testing</span>
frame := []byte{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
    0x08, 0x06,
    <span class="comment">// Payload omitted for brevity</span>
}

<span class="comment">// Run our VM&#39;s BPF program using the Ethernet frame as input</span>
out, err := vm.Run(frame)
if err != nil {
    panic(fmt.Sprintf(&#34;failed to accept Ethernet frame: %v&#34;, err))
}

<span class="comment">// BPF VM can return a byte count greater than the number of input</span>
<span class="comment">// bytes, so trim the output to match the input byte length</span>
if out &gt; len(frame) {
    out = len(frame)
}

fmt.Printf(&#34;out: %d bytes&#34;, out)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">out: 14 bytes
</pre>
			
		
	</div>
</div>

				
			

			
				
				<h3 id="VM.Run">func (*VM) <a href="http://localhost:6060/src/golang.org/x/net/bpf/vm.go?s=2473:2513#L75">Run</a>
					<a class="permalink" href="index.html#VM.Run">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="index.html#VM">VM</a>) Run(in []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Run runs the VM&#39;s BPF program against the input bytes.
Run returns the number of bytes accepted by the BPF program, and any errors
which occurred while processing the program.
</p>

				
				
				
			
		
	

	







<div id="footer">
Build version go1.11.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6060/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

</body>
</html>

