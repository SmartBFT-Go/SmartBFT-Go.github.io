<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ipv4 - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../../../../lib/godoc/style.css">


<script>window.initFuncs = [];</script>

<script src="../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.11.5";</script>
<script src="../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/">Go</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">
<a href="http://localhost:6060/doc/">Documents</a>
<a href="../../../../index.html">Packages</a>
<a href="http://localhost:6060/project/">The Project</a>
<a href="http://localhost:6060/help/">Help</a>

<a href="http://localhost:6060/blog/">Blog</a>


<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ipv4
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/net/ipv4"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package ipv4 implements IP-level socket options for the Internet
Protocol version 4.
</p>
<p>
The package provides IP-level socket options that allow
manipulation of IPv4 facilities.
</p>
<p>
The IPv4 protocol and basic host requirements for IPv4 are defined
in RFC 791 and RFC 1122.
Host extensions for multicasting and socket interface extensions
for multicast source filters are defined in RFC 1112 and RFC 3678.
IGMPv1, IGMPv2 and IGMPv3 are defined in RFC 1112, RFC 2236 and RFC
3376.
Source-specific multicast is defined in RFC 4607.
</p>
<h3 id="hdr-Unicasting">Unicasting</h3>
<p>
The options for unicasting are available for net.TCPConn,
net.UDPConn and net.IPConn which are created as network connections
that use the IPv4 transport. When a single TCP connection carrying
a data flow of multiple packets needs to indicate the flow is
important, Conn is used to set the type-of-service field on the
IPv4 header for each packet.
</p>
<pre>ln, err := net.Listen(&#34;tcp4&#34;, &#34;0.0.0.0:1024&#34;)
if err != nil {
	// error handling
}
defer ln.Close()
for {
	c, err := ln.Accept()
	if err != nil {
		// error handling
	}
	go func(c net.Conn) {
		defer c.Close()
</pre>
<p>
The outgoing packets will be labeled DiffServ assured forwarding
class 1 low drop precedence, known as AF11 packets.
</p>
<pre>		if err := ipv4.NewConn(c).SetTOS(0x28); err != nil {
			// error handling
		}
		if _, err := c.Write(data); err != nil {
			// error handling
		}
	}(c)
}
</pre>
<h3 id="hdr-Multicasting">Multicasting</h3>
<p>
The options for multicasting are available for net.UDPConn and
net.IPConn which are created as network connections that use the
IPv4 transport. A few network facilities must be prepared before
you begin multicasting, at a minimum joining network interfaces and
multicast groups.
</p>
<pre>en0, err := net.InterfaceByName(&#34;en0&#34;)
if err != nil {
	// error handling
}
en1, err := net.InterfaceByIndex(911)
if err != nil {
	// error handling
}
group := net.IPv4(224, 0, 0, 250)
</pre>
<p>
First, an application listens to an appropriate address with an
appropriate service port.
</p>
<pre>c, err := net.ListenPacket(&#34;udp4&#34;, &#34;0.0.0.0:1024&#34;)
if err != nil {
	// error handling
}
defer c.Close()
</pre>
<p>
Second, the application joins multicast groups, starts listening to
the groups on the specified network interfaces. Note that the
service port for transport layer protocol does not matter with this
operation as joining groups affects only network and link layer
protocols, such as IPv4 and Ethernet.
</p>
<pre>p := ipv4.NewPacketConn(c)
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: group}); err != nil {
	// error handling
}
if err := p.JoinGroup(en1, &amp;net.UDPAddr{IP: group}); err != nil {
	// error handling
}
</pre>
<p>
The application might set per packet control message transmissions
between the protocol stack within the kernel. When the application
needs a destination address on an incoming packet,
SetControlMessage of PacketConn is used to enable control message
transmissions.
</p>
<pre>if err := p.SetControlMessage(ipv4.FlagDst, true); err != nil {
	// error handling
}
</pre>
<p>
The application could identify whether the received packets are
of interest by using the control message that contains the
destination address of the received packet.
</p>
<pre>b := make([]byte, 1500)
for {
	n, cm, src, err := p.ReadFrom(b)
	if err != nil {
		// error handling
	}
	if cm.Dst.IsMulticast() {
		if cm.Dst.Equal(group) {
			// joined group, do something
		} else {
			// unknown group, discard
			continue
		}
	}
</pre>
<p>
The application can also send both unicast and multicast packets.
</p>
<pre>	p.SetTOS(0x0)
	p.SetTTL(16)
	if _, err := p.WriteTo(data, nil, src); err != nil {
		// error handling
	}
	dst := &amp;net.UDPAddr{IP: group, Port: 1024}
	for _, ifi := range []*net.Interface{en0, en1} {
		if err := p.SetMulticastInterface(ifi); err != nil {
			// error handling
		}
		p.SetMulticastTTL(2)
		if _, err := p.WriteTo(data, nil, dst); err != nil {
			// error handling
		}
	}
}
</pre>
<h3 id="hdr-More_multicasting">More multicasting</h3>
<p>
An application that uses PacketConn or RawConn may join multiple
multicast groups. For example, a UDP listener with port 1024 might
join two different groups across over two different network
interfaces by using:
</p>
<pre>c, err := net.ListenPacket(&#34;udp4&#34;, &#34;0.0.0.0:1024&#34;)
if err != nil {
	// error handling
}
defer c.Close()
p := ipv4.NewPacketConn(c)
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 249)}); err != nil {
	// error handling
}
if err := p.JoinGroup(en1, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 249)}); err != nil {
	// error handling
}
</pre>
<p>
It is possible for multiple UDP listeners that listen on the same
UDP port to join the same multicast group. The net package will
provide a socket that listens to a wildcard address with reusable
UDP port when an appropriate multicast address prefix is passed to
the net.ListenPacket or net.ListenUDP.
</p>
<pre>c1, err := net.ListenPacket(&#34;udp4&#34;, &#34;224.0.0.0:1024&#34;)
if err != nil {
	// error handling
}
defer c1.Close()
c2, err := net.ListenPacket(&#34;udp4&#34;, &#34;224.0.0.0:1024&#34;)
if err != nil {
	// error handling
}
defer c2.Close()
p1 := ipv4.NewPacketConn(c1)
if err := p1.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
p2 := ipv4.NewPacketConn(c2)
if err := p2.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
</pre>
<p>
Also it is possible for the application to leave or rejoin a
multicast group on the network interface.
</p>
<pre>if err := p.LeaveGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 248)}); err != nil {
	// error handling
}
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: net.IPv4(224, 0, 0, 250)}); err != nil {
	// error handling
}
</pre>
<h3 id="hdr-Source_specific_multicasting">Source-specific multicasting</h3>
<p>
An application that uses PacketConn or RawConn on IGMPv3 supported
platform is able to join source-specific multicast groups.
The application may use JoinSourceSpecificGroup and
LeaveSourceSpecificGroup for the operation known as &#34;include&#34; mode,
</p>
<pre>ssmgroup := net.UDPAddr{IP: net.IPv4(232, 7, 8, 9)}
ssmsource := net.UDPAddr{IP: net.IPv4(192, 168, 0, 1)})
if err := p.JoinSourceSpecificGroup(en0, &amp;ssmgroup, &amp;ssmsource); err != nil {
	// error handling
}
if err := p.LeaveSourceSpecificGroup(en0, &amp;ssmgroup, &amp;ssmsource); err != nil {
	// error handling
}
</pre>
<p>
or JoinGroup, ExcludeSourceSpecificGroup,
IncludeSourceSpecificGroup and LeaveGroup for the operation known
as &#34;exclude&#34; mode.
</p>
<pre>exclsource := net.UDPAddr{IP: net.IPv4(192, 168, 0, 254)}
if err := p.JoinGroup(en0, &amp;ssmgroup); err != nil {
	// error handling
}
if err := p.ExcludeSourceSpecificGroup(en0, &amp;ssmgroup, &amp;exclsource); err != nil {
	// error handling
}
if err := p.LeaveGroup(en0, &amp;ssmgroup); err != nil {
	// error handling
}
</pre>
<p>
Note that it depends on each platform implementation what happens
when an application which runs on IGMPv3 unsupported platform uses
JoinSourceSpecificGroup and LeaveSourceSpecificGroup.
In general the platform tries to fall back to conversations using
IGMPv1 or IGMPv2 and starts to listen to multicast traffic.
In the fallback case, ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup may return an error.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="index.html#NewControlMessage">func NewControlMessage(cf ControlFlags) []byte</a></dd>
			
			
				
				<dd><a href="index.html#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewConn">func NewConn(c net.Conn) *Conn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetTOS">func (c *Conn) SetTOS(tos int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetTTL">func (c *Conn) SetTTL(ttl int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.TOS">func (c *Conn) TOS() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.TTL">func (c *Conn) TTL() (int, error)</a></dd>
				
			
				
				<dd><a href="index.html#ControlFlags">type ControlFlags</a></dd>
				
				
			
				
				<dd><a href="index.html#ControlMessage">type ControlMessage</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ControlMessage.Marshal">func (cm *ControlMessage) Marshal() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ControlMessage.Parse">func (cm *ControlMessage) Parse(b []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ControlMessage.String">func (cm *ControlMessage) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Header">type Header</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ParseHeader">func ParseHeader(b []byte) (*Header, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Header.Marshal">func (h *Header) Marshal() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Header.Parse">func (h *Header) Parse(b []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Header.String">func (h *Header) String() string</a></dd>
				
			
				
				<dd><a href="index.html#HeaderFlags">type HeaderFlags</a></dd>
				
				
			
				
				<dd><a href="index.html#ICMPFilter">type ICMPFilter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.Accept">func (f *ICMPFilter) Accept(typ ICMPType)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.Block">func (f *ICMPFilter) Block(typ ICMPType)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.SetAll">func (f *ICMPFilter) SetAll(block bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.WillBlock">func (f *ICMPFilter) WillBlock(typ ICMPType) bool</a></dd>
				
			
				
				<dd><a href="index.html#ICMPType">type ICMPType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPType.Protocol">func (typ ICMPType) Protocol() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPType.String">func (typ ICMPType) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Message">type Message</a></dd>
				
				
			
				
				<dd><a href="index.html#PacketConn">type PacketConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewPacketConn">func NewPacketConn(c net.PacketConn) *PacketConn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.Close">func (c *PacketConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ExcludeSourceSpecificGroup">func (c *PacketConn) ExcludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ICMPFilter">func (c *PacketConn) ICMPFilter() (*ICMPFilter, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.IncludeSourceSpecificGroup">func (c *PacketConn) IncludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.JoinGroup">func (c *PacketConn) JoinGroup(ifi *net.Interface, group net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.JoinSourceSpecificGroup">func (c *PacketConn) JoinSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.LeaveGroup">func (c *PacketConn) LeaveGroup(ifi *net.Interface, group net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.LeaveSourceSpecificGroup">func (c *PacketConn) LeaveSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.MulticastInterface">func (c *PacketConn) MulticastInterface() (*net.Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.MulticastLoopback">func (c *PacketConn) MulticastLoopback() (bool, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.MulticastTTL">func (c *PacketConn) MulticastTTL() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ReadBatch">func (c *PacketConn) ReadBatch(ms []Message, flags int) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ReadFrom">func (c *PacketConn) ReadFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetBPF">func (c *PacketConn) SetBPF(filter []bpf.RawInstruction) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetControlMessage">func (c *PacketConn) SetControlMessage(cf ControlFlags, on bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetDeadline">func (c *PacketConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetICMPFilter">func (c *PacketConn) SetICMPFilter(f *ICMPFilter) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetMulticastInterface">func (c *PacketConn) SetMulticastInterface(ifi *net.Interface) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetMulticastLoopback">func (c *PacketConn) SetMulticastLoopback(on bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetMulticastTTL">func (c *PacketConn) SetMulticastTTL(ttl int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetReadDeadline">func (c *PacketConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetTOS">func (c *PacketConn) SetTOS(tos int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetTTL">func (c *PacketConn) SetTTL(ttl int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetWriteDeadline">func (c *PacketConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.TOS">func (c *PacketConn) TOS() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.TTL">func (c *PacketConn) TTL() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.WriteBatch">func (c *PacketConn) WriteBatch(ms []Message, flags int) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.WriteTo">func (c *PacketConn) WriteTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error)</a></dd>
				
			
				
				<dd><a href="index.html#RawConn">type RawConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewRawConn">func NewRawConn(c net.PacketConn) (*RawConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.Close">func (c *RawConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.ExcludeSourceSpecificGroup">func (c *RawConn) ExcludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.ICMPFilter">func (c *RawConn) ICMPFilter() (*ICMPFilter, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.IncludeSourceSpecificGroup">func (c *RawConn) IncludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.JoinGroup">func (c *RawConn) JoinGroup(ifi *net.Interface, group net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.JoinSourceSpecificGroup">func (c *RawConn) JoinSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.LeaveGroup">func (c *RawConn) LeaveGroup(ifi *net.Interface, group net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.LeaveSourceSpecificGroup">func (c *RawConn) LeaveSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.MulticastInterface">func (c *RawConn) MulticastInterface() (*net.Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.MulticastLoopback">func (c *RawConn) MulticastLoopback() (bool, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.MulticastTTL">func (c *RawConn) MulticastTTL() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.ReadBatch">func (c *RawConn) ReadBatch(ms []Message, flags int) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.ReadFrom">func (c *RawConn) ReadFrom(b []byte) (h *Header, p []byte, cm *ControlMessage, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetBPF">func (c *RawConn) SetBPF(filter []bpf.RawInstruction) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetControlMessage">func (c *RawConn) SetControlMessage(cf ControlFlags, on bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetDeadline">func (c *RawConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetICMPFilter">func (c *RawConn) SetICMPFilter(f *ICMPFilter) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetMulticastInterface">func (c *RawConn) SetMulticastInterface(ifi *net.Interface) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetMulticastLoopback">func (c *RawConn) SetMulticastLoopback(on bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetMulticastTTL">func (c *RawConn) SetMulticastTTL(ttl int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetReadDeadline">func (c *RawConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetTOS">func (c *RawConn) SetTOS(tos int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetTTL">func (c *RawConn) SetTTL(ttl int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.SetWriteDeadline">func (c *RawConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.TOS">func (c *RawConn) TOS() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.TTL">func (c *RawConn) TTL() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.WriteBatch">func (c *RawConn) WriteBatch(ms []Message, flags int) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#RawConn.WriteTo">func (c *RawConn) WriteTo(h *Header, p []byte, cm *ControlMessage) error</a></dd>
				
			
			
				
				<dd><a href="index.html#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Conn_markingTCP">Conn (MarkingTCP)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_PacketConn_servingOneShotMulticastDNS">PacketConn (ServingOneShotMulticastDNS)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_PacketConn_tracingIPPacketRoute">PacketConn (TracingIPPacketRoute)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_RawConn_advertisingOSPFHello">RawConn (AdvertisingOSPFHello)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go">batch.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go">control.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/control_pktinfo.go">control_pktinfo.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/control_unix.go">control_unix.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go">dgramopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go">endpoint.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go">genericopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go">header.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/helper.go">helper.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/iana.go">iana.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go">icmp.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp_linux.go">icmp_linux.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/packet.go">packet.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/packet_go1_9.go">packet_go1_9.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/payload.go">payload.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/payload_cmsg.go">payload_cmsg.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/payload_cmsg_go1_9.go">payload_cmsg_go1_9.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sockopt.go">sockopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sockopt_posix.go">sockopt_posix.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sys_asmreq_stub.go">sys_asmreq_stub.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sys_asmreqn.go">sys_asmreqn.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sys_bpf.go">sys_bpf.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sys_linux.go">sys_linux.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/sys_ssmreq.go">sys_ssmreq.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv4/zsys_linux_amd64.go">zsys_linux_amd64.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span id="Version">Version</span>   = 4  <span class="comment">// protocol version</span>
    <span id="HeaderLen">HeaderLen</span> = 20 <span class="comment">// header length without extension headers</span>

)</pre>
			
		
		
		
			
			
			<h2 id="NewControlMessage">func <a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go?s=3085:3131#L93">NewControlMessage</a>
				<a class="permalink" href="index.html#NewControlMessage">&#xb6;</a>
				
				
			</h2>
			<pre>func NewControlMessage(cf <a href="index.html#ControlFlags">ControlFlags</a>) []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a></pre>
			<p>
NewControlMessage returns a new control message.
</p>
<p>
The returned message is large enough for options specified by cf.
</p>

			
			

		
		
			
			
			<h2 id="Conn">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=592:624#L12">Conn</a>
				<a class="permalink" href="index.html#Conn">&#xb6;</a>
				
				
			</h2>
			<p>
A Conn represents a network endpoint that uses the IPv4 transport.
It is used to control basic IP-level socket options such as TOS and
TTL.
</p>

			<pre>type Conn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Conn_markingTCP" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (MarkingTCP)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (MarkingTCP)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
ln, err := net.Listen(&#34;tcp&#34;, &#34;0.0.0.0:1024&#34;)
if err != nil {
    log.Fatal(err)
}
defer ln.Close()

for {
    c, err := ln.Accept()
    if err != nil {
        log.Fatal(err)
    }
    go func(c net.Conn) {
        defer c.Close()
        if c.RemoteAddr().(*net.TCPAddr).IP.To4() != nil {
            p := ipv4.NewConn(c)
            if err := p.SetTOS(0x28); err != nil { <span class="comment">// DSCP AF11</span>
                log.Fatal(err)
            }
            if err := p.SetTTL(128); err != nil {
                log.Fatal(err)
            }
        }
        if _, err := c.Write([]byte(&#34;HELLO-R-U-THERE-ACK&#34;)); err != nil {
            log.Fatal(err)
        }
    }(c)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewConn">func <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=768:798#L23">NewConn</a>
					<a class="permalink" href="index.html#NewConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConn(c <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Conn">Conn</a>) *<a href="index.html#Conn">Conn</a></pre>
				<p>
NewConn returns a new Conn.
</p>

				
				
			

			
				
				<h3 id="Conn.SetTOS">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=505:547#L11">SetTOS</a>
					<a class="permalink" href="index.html#Conn.SetTOS">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetTOS(tos <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTOS sets the type-of-service field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="Conn.SetTTL">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=1015:1057#L36">SetTTL</a>
					<a class="permalink" href="index.html#Conn.SetTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetTTL(ttl <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTTL sets the time-to-live field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="Conn.TOS">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=243:282#L1">TOS</a>
					<a class="permalink" href="index.html#Conn.TOS">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) TOS() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TOS returns the type-of-service field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="Conn.TTL">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=756:795#L23">TTL</a>
					<a class="permalink" href="index.html#Conn.TTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) TTL() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TTL returns the time-to-live field value for outgoing packets.
</p>

				
				
				
			
		
			
			
			<h2 id="ControlFlags">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go?s=535:557#L15">ControlFlags</a>
				<a class="permalink" href="index.html#ControlFlags">&#xb6;</a>
				
				
			</h2>
			
			<pre>type ControlFlags <a href="http://localhost:6060/pkg/builtin/#uint">uint</a></pre>

			
				
				<pre>const (
    <span id="FlagTTL">FlagTTL</span>       <a href="index.html#ControlFlags">ControlFlags</a> = 1 &lt;&lt; <a href="http://localhost:6060/pkg/builtin/#iota">iota</a> <span class="comment">// pass the TTL on the received packet</span>
    <span id="FlagSrc">FlagSrc</span>                                <span class="comment">// pass the source address on the received packet</span>
    <span id="FlagDst">FlagDst</span>                                <span class="comment">// pass the destination address on the received packet</span>
    <span id="FlagInterface">FlagInterface</span>                          <span class="comment">// pass the interface index on the received packet</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="ControlMessage">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go?s=998:1567#L25">ControlMessage</a>
				<a class="permalink" href="index.html#ControlMessage">&#xb6;</a>
				
				
			</h2>
			<p>
A ControlMessage represents per packet basis IP-level socket options.
</p>

			<pre>type ControlMessage struct {
    <span class="comment">// Receiving socket options: SetControlMessage allows to</span>
    <span class="comment">// receive the options from the protocol stack using ReadFrom</span>
    <span class="comment">// method of PacketConn or RawConn.</span>
    <span class="comment">//</span>
    <span class="comment">// Specifying socket options: ControlMessage for WriteTo</span>
    <span class="comment">// method of PacketConn or RawConn allows to send the options</span>
    <span class="comment">// to the protocol stack.</span>
    <span class="comment">//</span>
<span id="ControlMessage.TTL"></span>    TTL     <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// time-to-live, receiving only</span>
<span id="ControlMessage.Src"></span>    Src     <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// source address, specifying only</span>
<span id="ControlMessage.Dst"></span>    Dst     <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// destination address, receiving only</span>
<span id="ControlMessage.IfIndex"></span>    IfIndex <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// interface index, must be 1 &lt;= value when specifying</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ControlMessage.Marshal">func (*ControlMessage) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go?s=1789:1831#L48">Marshal</a>
					<a class="permalink" href="index.html#ControlMessage.Marshal">&#xb6;</a>
					
					
				</h3>
				<pre>func (cm *<a href="index.html#ControlMessage">ControlMessage</a>) Marshal() []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a></pre>
				<p>
Marshal returns the binary encoding of cm.
</p>

				
				
				
			
				
				<h3 id="ControlMessage.Parse">func (*ControlMessage) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go?s=2189:2236#L63">Parse</a>
					<a class="permalink" href="index.html#ControlMessage.Parse">&#xb6;</a>
					
					
				</h3>
				<pre>func (cm *<a href="index.html#ControlMessage">ControlMessage</a>) Parse(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Parse parses b as a control message and stores the result in cm.
</p>

				
				
				
			
				
				<h3 id="ControlMessage.String">func (*ControlMessage) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/control.go?s=1569:1610#L40">String</a>
					<a class="permalink" href="index.html#ControlMessage.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (cm *<a href="index.html#ControlMessage">ControlMessage</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Header">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go?s=690:1239#L20">Header</a>
				<a class="permalink" href="index.html#Header">&#xb6;</a>
				
				
			</h2>
			<p>
A Header represents an IPv4 header.
</p>

			<pre>type Header struct {
<span id="Header.Version"></span>    Version  <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// protocol version</span>
<span id="Header.Len"></span>    Len      <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// header length</span>
<span id="Header.TOS"></span>    TOS      <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// type-of-service</span>
<span id="Header.TotalLen"></span>    TotalLen <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// packet total length</span>
<span id="Header.ID"></span>    ID       <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// identification</span>
<span id="Header.Flags"></span>    Flags    <a href="index.html#HeaderFlags">HeaderFlags</a> <span class="comment">// flags</span>
<span id="Header.FragOff"></span>    FragOff  <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// fragment offset</span>
<span id="Header.TTL"></span>    TTL      <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// time-to-live</span>
<span id="Header.Protocol"></span>    Protocol <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// next protocol</span>
<span id="Header.Checksum"></span>    Checksum <a href="http://localhost:6060/pkg/builtin/#int">int</a>         <span class="comment">// checksum</span>
<span id="Header.Src"></span>    Src      <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a>      <span class="comment">// source address</span>
<span id="Header.Dst"></span>    Dst      <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a>      <span class="comment">// destination address</span>
<span id="Header.Options"></span>    Options  []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>      <span class="comment">// options, extension headers</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ParseHeader">func <a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go?s=5013:5056#L154">ParseHeader</a>
					<a class="permalink" href="index.html#ParseHeader">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseHeader(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) (*<a href="index.html#Header">Header</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseHeader parses b as an IPv4 header.
</p>
<p>
The provided b must be in the format used by a raw IP socket on the
local system.
This may differ from the wire format, depending on the system.
</p>

				
				
			

			
				
				<h3 id="Header.Marshal">func (*Header) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go?s=1752:1794#L48">Marshal</a>
					<a class="permalink" href="index.html#Header.Marshal">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#Header">Header</a>) Marshal() ([]<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Marshal returns the binary encoding of h.
</p>
<p>
The returned slice is in the format used by a raw IP socket on the
local system.
This may differ from the wire format, depending on the system.
</p>

				
				
				
			
				
				<h3 id="Header.Parse">func (*Header) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go?s=3368:3406#L99">Parse</a>
					<a class="permalink" href="index.html#Header.Parse">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#Header">Header</a>) Parse(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Parse parses b as an IPv4 header and stores the result in h.
</p>
<p>
The provided b must be in the format used by a raw IP socket on the
local system.
This may differ from the wire format, depending on the system.
</p>

				
				
				
			
				
				<h3 id="Header.String">func (*Header) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go?s=1241:1273#L36">String</a>
					<a class="permalink" href="index.html#Header.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#Header">Header</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="HeaderFlags">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/header.go?s=494:514#L12">HeaderFlags</a>
				<a class="permalink" href="index.html#HeaderFlags">&#xb6;</a>
				
				
			</h2>
			
			<pre>type HeaderFlags <a href="http://localhost:6060/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span id="MoreFragments">MoreFragments</span> <a href="index.html#HeaderFlags">HeaderFlags</a> = 1 &lt;&lt; <a href="http://localhost:6060/pkg/builtin/#iota">iota</a> <span class="comment">// more fragments flag</span>
    <span id="DontFragment">DontFragment</span>                          <span class="comment">// don&#39;t fragment flag</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="ICMPFilter">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=984:1022#L23">ICMPFilter</a>
				<a class="permalink" href="index.html#ICMPFilter">&#xb6;</a>
				
				
			</h2>
			<p>
An ICMPFilter represents an ICMP message filter for incoming
packets. The filter belongs to a packet delivery path on a host and
it cannot interact with forwarding packets or tunnel-outer packets.
</p>
<p>
Note: RFC 8200 defines a reasonable role model and it works not
only for IPv6 but IPv4. A node means a device that implements IP.
A router means a node that forwards IP packets not explicitly
addressed to itself, and a host means a node that is not a router.
</p>

			<pre>type ICMPFilter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ICMPFilter.Accept">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=1103:1144#L29">Accept</a>
					<a class="permalink" href="index.html#ICMPFilter.Accept">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) Accept(typ <a href="index.html#ICMPType">ICMPType</a>)</pre>
				<p>
Accept accepts incoming ICMP packets including the type field value
typ.
</p>

				
				
				
			
				
				<h3 id="ICMPFilter.Block">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=1242:1282#L35">Block</a>
					<a class="permalink" href="index.html#ICMPFilter.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) Block(typ <a href="index.html#ICMPType">ICMPType</a>)</pre>
				<p>
Block blocks incoming ICMP packets including the type field value
typ.
</p>

				
				
				
			
				
				<h3 id="ICMPFilter.SetAll">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=1350:1389#L40">SetAll</a>
					<a class="permalink" href="index.html#ICMPFilter.SetAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) SetAll(block <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetAll sets the filter action to the filter.
</p>

				
				
				
			
				
				<h3 id="ICMPFilter.WillBlock">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=1472:1521#L45">WillBlock</a>
					<a class="permalink" href="index.html#ICMPFilter.WillBlock">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) WillBlock(typ <a href="index.html#ICMPType">ICMPType</a>) <a href="http://localhost:6060/pkg/builtin/#bool">bool</a></pre>
				<p>
WillBlock reports whether the ICMP type will be blocked.
</p>

				
				
				
			
		
			
			
			<h2 id="ICMPType">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=265:282#L1">ICMPType</a>
				<a class="permalink" href="index.html#ICMPType">&#xb6;</a>
				
				
			</h2>
			<p>
An ICMPType represents a type of ICMP message.
</p>

			<pre>type ICMPType <a href="http://localhost:6060/pkg/builtin/#int">int</a></pre>

			
				<p>
Internet Control Message Protocol (ICMP) Parameters, Updated: 2018-02-26
</p>

				<pre>const (
    <span id="ICMPTypeEchoReply">ICMPTypeEchoReply</span>              <a href="index.html#ICMPType">ICMPType</a> = 0  <span class="comment">// Echo Reply</span>
    <span id="ICMPTypeDestinationUnreachable">ICMPTypeDestinationUnreachable</span> <a href="index.html#ICMPType">ICMPType</a> = 3  <span class="comment">// Destination Unreachable</span>
    <span id="ICMPTypeRedirect">ICMPTypeRedirect</span>               <a href="index.html#ICMPType">ICMPType</a> = 5  <span class="comment">// Redirect</span>
    <span id="ICMPTypeEcho">ICMPTypeEcho</span>                   <a href="index.html#ICMPType">ICMPType</a> = 8  <span class="comment">// Echo</span>
    <span id="ICMPTypeRouterAdvertisement">ICMPTypeRouterAdvertisement</span>    <a href="index.html#ICMPType">ICMPType</a> = 9  <span class="comment">// Router Advertisement</span>
    <span id="ICMPTypeRouterSolicitation">ICMPTypeRouterSolicitation</span>     <a href="index.html#ICMPType">ICMPType</a> = 10 <span class="comment">// Router Solicitation</span>
    <span id="ICMPTypeTimeExceeded">ICMPTypeTimeExceeded</span>           <a href="index.html#ICMPType">ICMPType</a> = 11 <span class="comment">// Time Exceeded</span>
    <span id="ICMPTypeParameterProblem">ICMPTypeParameterProblem</span>       <a href="index.html#ICMPType">ICMPType</a> = 12 <span class="comment">// Parameter Problem</span>
    <span id="ICMPTypeTimestamp">ICMPTypeTimestamp</span>              <a href="index.html#ICMPType">ICMPType</a> = 13 <span class="comment">// Timestamp</span>
    <span id="ICMPTypeTimestampReply">ICMPTypeTimestampReply</span>         <a href="index.html#ICMPType">ICMPType</a> = 14 <span class="comment">// Timestamp Reply</span>
    <span id="ICMPTypePhoturis">ICMPTypePhoturis</span>               <a href="index.html#ICMPType">ICMPType</a> = 40 <span class="comment">// Photuris</span>
    <span id="ICMPTypeExtendedEchoRequest">ICMPTypeExtendedEchoRequest</span>    <a href="index.html#ICMPType">ICMPType</a> = 42 <span class="comment">// Extended Echo Request</span>
    <span id="ICMPTypeExtendedEchoReply">ICMPTypeExtendedEchoReply</span>      <a href="index.html#ICMPType">ICMPType</a> = 43 <span class="comment">// Extended Echo Reply</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="ICMPType.Protocol">func (ICMPType) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=438:472#L11">Protocol</a>
					<a class="permalink" href="index.html#ICMPType.Protocol">&#xb6;</a>
					
					
				</h3>
				<pre>func (typ <a href="index.html#ICMPType">ICMPType</a>) Protocol() <a href="http://localhost:6060/pkg/builtin/#int">int</a></pre>
				<p>
Protocol returns the ICMPv4 protocol number.
</p>

				
				
				
			
				
				<h3 id="ICMPType.String">func (ICMPType) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/icmp.go?s=284:319#L2">String</a>
					<a class="permalink" href="index.html#ICMPType.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (typ <a href="index.html#ICMPType">ICMPType</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Message">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=1626:1655#L48">Message</a>
				<a class="permalink" href="index.html#Message">&#xb6;</a>
				
				
			</h2>
			<p>
A Message represents an IO message.
</p>
<pre>type Message struct {
	Buffers [][]byte
	OOB     []byte
	Addr    net.Addr
	N       int
	NN      int
	Flags   int
}
</pre>
<p>
The Buffers fields represents a list of contiguous buffers, which
can be used for vectored IO, for example, putting a header and a
payload in each slice.
When writing, the Buffers field must contain at least one byte to
write.
When reading, the Buffers field will always contain a byte to read.
</p>
<p>
The OOB field contains protocol-specific control or miscellaneous
ancillary data known as out-of-band data.
It can be nil when not required.
</p>
<p>
The Addr field specifies a destination address when writing.
It can be nil when the underlying protocol of the endpoint uses
connection-oriented communication.
After a successful read, it may contain the source address on the
received packet.
</p>
<p>
The N field indicates the number of bytes read or written from/to
Buffers.
</p>
<p>
The NN field indicates the number of bytes read or written from/to
OOB.
</p>
<p>
The Flags field contains protocol-specific information on the
received message.
</p>

			<pre>type Message = <a href="../internal/socket/index.html">socket</a>.<a href="../internal/socket/index.html#Message">Message</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PacketConn">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=1172:1236#L35">PacketConn</a>
				<a class="permalink" href="index.html#PacketConn">&#xb6;</a>
				
				
			</h2>
			<p>
A PacketConn represents a packet network endpoint that uses the
IPv4 transport. It is used to control several IP-level socket
options including multicasting. It also provides datagram based
network I/O methods specific to the IPv4 and higher layer protocols
such as UDP.
</p>

			<pre>type PacketConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_PacketConn_servingOneShotMulticastDNS" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (ServingOneShotMulticastDNS)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (ServingOneShotMulticastDNS)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
c, err := net.ListenPacket(&#34;udp4&#34;, &#34;0.0.0.0:5353&#34;) <span class="comment">// mDNS over UDP</span>
if err != nil {
    log.Fatal(err)
}
defer c.Close()
p := ipv4.NewPacketConn(c)

en0, err := net.InterfaceByName(&#34;en0&#34;)
if err != nil {
    log.Fatal(err)
}
mDNSLinkLocal := net.UDPAddr{IP: net.IPv4(224, 0, 0, 251)}
if err := p.JoinGroup(en0, &amp;mDNSLinkLocal); err != nil {
    log.Fatal(err)
}
defer p.LeaveGroup(en0, &amp;mDNSLinkLocal)
if err := p.SetControlMessage(ipv4.FlagDst, true); err != nil {
    log.Fatal(err)
}

b := make([]byte, 1500)
for {
    _, cm, peer, err := p.ReadFrom(b)
    if err != nil {
        log.Fatal(err)
    }
    if !cm.Dst.IsMulticast() || !cm.Dst.Equal(mDNSLinkLocal.IP) {
        continue
    }
    answers := []byte(&#34;FAKE-MDNS-ANSWERS&#34;) <span class="comment">// fake mDNS answers, you need to implement this</span>
    if _, err := p.WriteTo(answers, nil, peer); err != nil {
        log.Fatal(err)
    }
}
</pre>
			
		
	</div>
</div>
<div id="example_PacketConn_tracingIPPacketRoute" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (TracingIPPacketRoute)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (TracingIPPacketRoute)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Tracing an IP packet route to www.google.com.</span>

const host = &#34;www.google.com&#34;
ips, err := net.LookupIP(host)
if err != nil {
    log.Fatal(err)
}
var dst net.IPAddr
for _, ip := range ips {
    if ip.To4() != nil {
        dst.IP = ip
        fmt.Printf(&#34;using %v for tracing an IP packet route to %s\n&#34;, dst.IP, host)
        break
    }
}
if dst.IP == nil {
    log.Fatal(&#34;no A record found&#34;)
}

c, err := net.ListenPacket(&#34;ip4:1&#34;, &#34;0.0.0.0&#34;) <span class="comment">// ICMP for IPv4</span>
if err != nil {
    log.Fatal(err)
}
defer c.Close()
p := ipv4.NewPacketConn(c)

if err := p.SetControlMessage(ipv4.FlagTTL|ipv4.FlagSrc|ipv4.FlagDst|ipv4.FlagInterface, true); err != nil {
    log.Fatal(err)
}
wm := icmp.Message{
    Type: ipv4.ICMPTypeEcho, Code: 0,
    Body: &amp;icmp.Echo{
        ID:   os.Getpid() &amp; 0xffff,
        Data: []byte(&#34;HELLO-R-U-THERE&#34;),
    },
}

rb := make([]byte, 1500)
for i := 1; i &lt;= 64; i++ { <span class="comment">// up to 64 hops</span>
    wm.Body.(*icmp.Echo).Seq = i
    wb, err := wm.Marshal(nil)
    if err != nil {
        log.Fatal(err)
    }
    if err := p.SetTTL(i); err != nil {
        log.Fatal(err)
    }

    <span class="comment">// In the real world usually there are several</span>
    <span class="comment">// multiple traffic-engineered paths for each hop.</span>
    <span class="comment">// You may need to probe a few times to each hop.</span>
    begin := time.Now()
    if _, err := p.WriteTo(wb, nil, &amp;dst); err != nil {
        log.Fatal(err)
    }
    if err := p.SetReadDeadline(time.Now().Add(3 * time.Second)); err != nil {
        log.Fatal(err)
    }
    n, cm, peer, err := p.ReadFrom(rb)
    if err != nil {
        if err, ok := err.(net.Error); ok &amp;&amp; err.Timeout() {
            fmt.Printf(&#34;%v\t*\n&#34;, i)
            continue
        }
        log.Fatal(err)
    }
    rm, err := icmp.ParseMessage(1, rb[:n])
    if err != nil {
        log.Fatal(err)
    }
    rtt := time.Since(begin)

    <span class="comment">// In the real world you need to determine whether the</span>
    <span class="comment">// received message is yours using ControlMessage.Src,</span>
    <span class="comment">// ControlMessage.Dst, icmp.Echo.ID and icmp.Echo.Seq.</span>
    switch rm.Type {
    case ipv4.ICMPTypeTimeExceeded:
        names, _ := net.LookupAddr(peer.String())
        fmt.Printf(&#34;%d\t%v %+v %v\n\t%+v\n&#34;, i, peer, names, rtt, cm)
    case ipv4.ICMPTypeEchoReply:
        names, _ := net.LookupAddr(peer.String())
        fmt.Printf(&#34;%d\t%v %+v %v\n\t%+v\n&#34;, i, peer, names, rtt, cm)
        return
    default:
        log.Printf(&#34;unknown ICMP message: %+v\n&#34;, rm)
    }
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewPacketConn">func <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=2616:2664#L92">NewPacketConn</a>
					<a class="permalink" href="index.html#NewPacketConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPacketConn(c <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#PacketConn">PacketConn</a>) *<a href="index.html#PacketConn">PacketConn</a></pre>
				<p>
NewPacketConn returns a new PacketConn using c as its underlying
transport.
</p>

				
				
			

			
				
				<h3 id="PacketConn.Close">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=2394:2428#L83">Close</a>
					<a class="permalink" href="index.html#PacketConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) Close() <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ExcludeSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=4874:4969#L176">ExcludeSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.ExcludeSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ExcludeSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
ExcludeSourceSpecificGroup excludes the source-specific group from
the already joined any-source groups by JoinGroup on the interface
ifi.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ICMPFilter">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=5928:5980#L218">ICMPFilter</a>
					<a class="permalink" href="index.html#PacketConn.ICMPFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ICMPFilter() (*<a href="index.html#ICMPFilter">ICMPFilter</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ICMPFilter returns an ICMP filter.
Currently only Linux supports this.
</p>

				
				
				
			
				
				<h3 id="PacketConn.IncludeSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=5429:5524#L197">IncludeSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.IncludeSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) IncludeSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
IncludeSourceSpecificGroup includes the excluded source-specific
group by ExcludeSourceSpecificGroup again on the interface ifi.
</p>

				
				
				
			
				
				<h3 id="PacketConn.JoinGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=2711:2781#L94">JoinGroup</a>
					<a class="permalink" href="index.html#PacketConn.JoinGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) JoinGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
JoinGroup joins the group address group on the interface ifi.
By default all sources that can cast data to group are accepted.
It&#39;s possible to mute and unmute data transmission from a specific
source by using ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup.
JoinGroup uses the system assigned multicast interface when ifi is
nil, although this is not recommended because the assignment
depends on platforms and sometimes it might require routing
configuration.
</p>

				
				
				
			
				
				<h3 id="PacketConn.JoinSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=3806:3898#L133">JoinSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.JoinSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) JoinSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
JoinSourceSpecificGroup joins the source-specific group comprising
group and source on the interface ifi.
JoinSourceSpecificGroup uses the system assigned multicast
interface when ifi is nil, although this is not recommended because
the assignment depends on platforms and sometimes it might require
routing configuration.
</p>

				
				
				
			
				
				<h3 id="PacketConn.LeaveGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=3162:3233#L112">LeaveGroup</a>
					<a class="permalink" href="index.html#PacketConn.LeaveGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) LeaveGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
LeaveGroup leaves the group address group on the interface ifi
regardless of whether the group is any-source group or
source-specific group.
</p>

				
				
				
			
				
				<h3 id="PacketConn.LeaveSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=4308:4401#L154">LeaveSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.LeaveSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) LeaveSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
LeaveSourceSpecificGroup leaves the source-specific group on the
interface ifi.
</p>

				
				
				
			
				
				<h3 id="PacketConn.MulticastInterface">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=892:955#L31">MulticastInterface</a>
					<a class="permalink" href="index.html#PacketConn.MulticastInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) MulticastInterface() (*<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastInterface returns the default interface for multicast
packet transmissions.
</p>

				
				
				
			
				
				<h3 id="PacketConn.MulticastLoopback">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=1590:1642#L57">MulticastLoopback</a>
					<a class="permalink" href="index.html#PacketConn.MulticastLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) MulticastLoopback() (<a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastLoopback reports whether transmitted multicast packets
should be copied and send back to the originator.
</p>

				
				
				
			
				
				<h3 id="PacketConn.MulticastTTL">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=306:352#L5">MulticastTTL</a>
					<a class="permalink" href="index.html#PacketConn.MulticastTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) MulticastTTL() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastTTL returns the time-to-live field value for outgoing
multicast packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ReadBatch">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=2278:2350#L66">ReadBatch</a>
					<a class="permalink" href="index.html#PacketConn.ReadBatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ReadBatch(ms []<a href="index.html#Message">Message</a>, flags <a href="http://localhost:6060/pkg/builtin/#int">int</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadBatch reads a batch of messages.
</p>
<p>
The provided flags is a set of platform-dependent flags, such as
syscall.MSG_PEEK.
</p>
<p>
On a successful read it returns the number of messages received, up
to len(ms).
</p>
<p>
On Linux, a batch read will be optimized.
On other platforms, this method will read only a single message.
</p>
<p>
Unlike the ReadFrom method, it doesn&#39;t strip the IPv4 header
followed by option headers from the received IPv4 datagram when the
underlying transport is net.IPConn. Each Buffers field of Message
must be large enough to accommodate an IPv4 header and option
headers.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ReadFrom">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/payload_cmsg.go?s=492:588#L5">ReadFrom</a>
					<a class="permalink" href="index.html#PacketConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ReadFrom(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) (n <a href="http://localhost:6060/pkg/builtin/#int">int</a>, cm *<a href="index.html#ControlMessage">ControlMessage</a>, src <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom reads a payload of the received IPv4 datagram, from the
endpoint c, copying the payload into b. It returns the number of
bytes copied into b, the control message cm and the source address
src of the received datagram.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetBPF">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=6514:6574#L245">SetBPF</a>
					<a class="permalink" href="index.html#PacketConn.SetBPF">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetBPF(filter []<a href="../bpf/index.html">bpf</a>.<a href="../bpf/index.html#RawInstruction">RawInstruction</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetBPF attaches a BPF program to the connection.
</p>
<p>
Only supported on Linux.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetControlMessage">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=1411:1481#L48">SetControlMessage</a>
					<a class="permalink" href="index.html#PacketConn.SetControlMessage">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetControlMessage(cf <a href="index.html#ControlFlags">ControlFlags</a>, on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetControlMessage sets the per packet IP-level socket options.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetDeadline">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=1702:1753#L57">SetDeadline</a>
					<a class="permalink" href="index.html#PacketConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline sets the read and write deadlines associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetICMPFilter">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=6223:6276#L231">SetICMPFilter</a>
					<a class="permalink" href="index.html#PacketConn.SetICMPFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetICMPFilter(f *<a href="index.html#ICMPFilter">ICMPFilter</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetICMPFilter deploys the ICMP filter.
Currently only Linux supports this.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetMulticastInterface">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=1231:1297#L44">SetMulticastInterface</a>
					<a class="permalink" href="index.html#PacketConn.SetMulticastInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetMulticastInterface(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastInterface sets the default interface for future
multicast packet transmissions.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetMulticastLoopback">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=1993:2047#L74">SetMulticastLoopback</a>
					<a class="permalink" href="index.html#PacketConn.SetMulticastLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetMulticastLoopback(on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastLoopback sets whether transmitted multicast packets
should be copied and send back to the originator.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetMulticastTTL">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=600:649#L18">SetMulticastTTL</a>
					<a class="permalink" href="index.html#PacketConn.SetMulticastTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetMulticastTTL(ttl <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastTTL sets the time-to-live field value for future
outgoing multicast packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetReadDeadline">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=1941:1996#L66">SetReadDeadline</a>
					<a class="permalink" href="index.html#PacketConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetReadDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline sets the read deadline associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetTOS">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=505:547#L11">SetTOS</a>
					<a class="permalink" href="index.html#PacketConn.SetTOS">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetTOS(tos <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTOS sets the type-of-service field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetTTL">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=1015:1057#L36">SetTTL</a>
					<a class="permalink" href="index.html#PacketConn.SetTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetTTL(ttl <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTTL sets the time-to-live field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetWriteDeadline">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=2190:2246#L75">SetWriteDeadline</a>
					<a class="permalink" href="index.html#PacketConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetWriteDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline sets the write deadline associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.TOS">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=243:282#L1">TOS</a>
					<a class="permalink" href="index.html#PacketConn.TOS">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) TOS() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TOS returns the type-of-service field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.TTL">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=756:795#L23">TTL</a>
					<a class="permalink" href="index.html#PacketConn.TTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) TTL() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TTL returns the time-to-live field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.WriteBatch">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=3197:3270#L97">WriteBatch</a>
					<a class="permalink" href="index.html#PacketConn.WriteBatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) WriteBatch(ms []<a href="index.html#Message">Message</a>, flags <a href="http://localhost:6060/pkg/builtin/#int">int</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteBatch writes a batch of messages.
</p>
<p>
The provided flags is a set of platform-dependent flags, such as
syscall.MSG_DONTROUTE.
</p>
<p>
It returns the number of messages written on a successful write.
</p>
<p>
On Linux, a batch write will be optimized.
On other platforms, this method will write only a single message.
</p>

				
				
				
			
				
				<h3 id="PacketConn.WriteTo">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/payload_cmsg.go?s=1067:1162#L18">WriteTo</a>
					<a class="permalink" href="index.html#PacketConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) WriteTo(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>, cm *<a href="index.html#ControlMessage">ControlMessage</a>, dst <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) (n <a href="http://localhost:6060/pkg/builtin/#int">int</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo writes a payload of the IPv4 datagram, to the destination
address dst through the endpoint c, copying the payload from b. It
returns the number of bytes written. The control message cm allows
the datagram path and the outgoing interface to be specified.
Currently only Darwin and Linux support this. The cm may be nil if
control of the outgoing datagram is not required.
</p>

				
				
				
			
		
			
			
			<h2 id="RawConn">type <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=3214:3274#L107">RawConn</a>
				<a class="permalink" href="index.html#RawConn">&#xb6;</a>
				
				
			</h2>
			<p>
A RawConn represents a packet network endpoint that uses the IPv4
transport. It is used to control several IP-level socket options
including IPv4 header manipulation. It also provides datagram
based network I/O methods specific to the IPv4 and higher layer
protocols that handle IPv4 datagram directly such as OSPF, GRE.
</p>

			<pre>type RawConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_RawConn_advertisingOSPFHello" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (AdvertisingOSPFHello)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (AdvertisingOSPFHello)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
c, err := net.ListenPacket(&#34;ip4:89&#34;, &#34;0.0.0.0&#34;) <span class="comment">// OSPF for IPv4</span>
if err != nil {
    log.Fatal(err)
}
defer c.Close()
r, err := ipv4.NewRawConn(c)
if err != nil {
    log.Fatal(err)
}

en0, err := net.InterfaceByName(&#34;en0&#34;)
if err != nil {
    log.Fatal(err)
}
allSPFRouters := net.IPAddr{IP: net.IPv4(224, 0, 0, 5)}
if err := r.JoinGroup(en0, &amp;allSPFRouters); err != nil {
    log.Fatal(err)
}
defer r.LeaveGroup(en0, &amp;allSPFRouters)

hello := make([]byte, 24) <span class="comment">// fake hello data, you need to implement this</span>
ospf := make([]byte, 24)  <span class="comment">// fake ospf header, you need to implement this</span>
ospf[0] = 2               <span class="comment">// version 2</span>
ospf[1] = 1               <span class="comment">// hello packet</span>
ospf = append(ospf, hello...)
iph := &amp;ipv4.Header{
    Version:  ipv4.Version,
    Len:      ipv4.HeaderLen,
    TOS:      0xc0, <span class="comment">// DSCP CS6</span>
    TotalLen: ipv4.HeaderLen + len(ospf),
    TTL:      1,
    Protocol: 89,
    Dst:      allSPFRouters.IP.To4(),
}

var cm *ipv4.ControlMessage
switch runtime.GOOS {
case &#34;darwin&#34;, &#34;linux&#34;:
    cm = &amp;ipv4.ControlMessage{IfIndex: en0.Index}
default:
    if err := r.SetMulticastInterface(en0); err != nil {
        log.Fatal(err)
    }
}
if err := r.WriteTo(iph, ospf, cm); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewRawConn">func <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=4500:4551#L158">NewRawConn</a>
					<a class="permalink" href="index.html#NewRawConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRawConn(c <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#PacketConn">PacketConn</a>) (*<a href="index.html#RawConn">RawConn</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
NewRawConn returns a new RawConn using c as its underlying
transport.
</p>

				
				
			

			
				
				<h3 id="RawConn.Close">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=4293:4324#L149">Close</a>
					<a class="permalink" href="index.html#RawConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) Close() <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the endpoint.
</p>

				
				
				
			
				
				<h3 id="RawConn.ExcludeSourceSpecificGroup">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=4874:4969#L176">ExcludeSourceSpecificGroup</a>
					<a class="permalink" href="index.html#RawConn.ExcludeSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) ExcludeSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
ExcludeSourceSpecificGroup excludes the source-specific group from
the already joined any-source groups by JoinGroup on the interface
ifi.
</p>

				
				
				
			
				
				<h3 id="RawConn.ICMPFilter">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=5928:5980#L218">ICMPFilter</a>
					<a class="permalink" href="index.html#RawConn.ICMPFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) ICMPFilter() (*<a href="index.html#ICMPFilter">ICMPFilter</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ICMPFilter returns an ICMP filter.
Currently only Linux supports this.
</p>

				
				
				
			
				
				<h3 id="RawConn.IncludeSourceSpecificGroup">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=5429:5524#L197">IncludeSourceSpecificGroup</a>
					<a class="permalink" href="index.html#RawConn.IncludeSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) IncludeSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
IncludeSourceSpecificGroup includes the excluded source-specific
group by ExcludeSourceSpecificGroup again on the interface ifi.
</p>

				
				
				
			
				
				<h3 id="RawConn.JoinGroup">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=2711:2781#L94">JoinGroup</a>
					<a class="permalink" href="index.html#RawConn.JoinGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) JoinGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
JoinGroup joins the group address group on the interface ifi.
By default all sources that can cast data to group are accepted.
It&#39;s possible to mute and unmute data transmission from a specific
source by using ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup.
JoinGroup uses the system assigned multicast interface when ifi is
nil, although this is not recommended because the assignment
depends on platforms and sometimes it might require routing
configuration.
</p>

				
				
				
			
				
				<h3 id="RawConn.JoinSourceSpecificGroup">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=3806:3898#L133">JoinSourceSpecificGroup</a>
					<a class="permalink" href="index.html#RawConn.JoinSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) JoinSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
JoinSourceSpecificGroup joins the source-specific group comprising
group and source on the interface ifi.
JoinSourceSpecificGroup uses the system assigned multicast
interface when ifi is nil, although this is not recommended because
the assignment depends on platforms and sometimes it might require
routing configuration.
</p>

				
				
				
			
				
				<h3 id="RawConn.LeaveGroup">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=3162:3233#L112">LeaveGroup</a>
					<a class="permalink" href="index.html#RawConn.LeaveGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) LeaveGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
LeaveGroup leaves the group address group on the interface ifi
regardless of whether the group is any-source group or
source-specific group.
</p>

				
				
				
			
				
				<h3 id="RawConn.LeaveSourceSpecificGroup">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=4308:4401#L154">LeaveSourceSpecificGroup</a>
					<a class="permalink" href="index.html#RawConn.LeaveSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) LeaveSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
LeaveSourceSpecificGroup leaves the source-specific group on the
interface ifi.
</p>

				
				
				
			
				
				<h3 id="RawConn.MulticastInterface">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=892:955#L31">MulticastInterface</a>
					<a class="permalink" href="index.html#RawConn.MulticastInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) MulticastInterface() (*<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastInterface returns the default interface for multicast
packet transmissions.
</p>

				
				
				
			
				
				<h3 id="RawConn.MulticastLoopback">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=1590:1642#L57">MulticastLoopback</a>
					<a class="permalink" href="index.html#RawConn.MulticastLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) MulticastLoopback() (<a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastLoopback reports whether transmitted multicast packets
should be copied and send back to the originator.
</p>

				
				
				
			
				
				<h3 id="RawConn.MulticastTTL">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=306:352#L5">MulticastTTL</a>
					<a class="permalink" href="index.html#RawConn.MulticastTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) MulticastTTL() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastTTL returns the time-to-live field value for outgoing
multicast packets.
</p>

				
				
				
			
				
				<h3 id="RawConn.ReadBatch">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=4128:4199#L129">ReadBatch</a>
					<a class="permalink" href="index.html#RawConn.ReadBatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) ReadBatch(ms []<a href="index.html#Message">Message</a>, flags <a href="http://localhost:6060/pkg/builtin/#int">int</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadBatch reads a batch of messages.
</p>
<p>
The provided flags is a set of platform-dependent flags, such as
syscall.MSG_PEEK.
</p>
<p>
On a successful read it returns the number of messages received, up
to len(ms).
</p>
<p>
On Linux, a batch read will be optimized.
On other platforms, this method will read only a single message.
</p>

				
				
				
			
				
				<h3 id="RawConn.ReadFrom">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/packet.go?s=728:823#L18">ReadFrom</a>
					<a class="permalink" href="index.html#RawConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) ReadFrom(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) (h *<a href="index.html#Header">Header</a>, p []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>, cm *<a href="index.html#ControlMessage">ControlMessage</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom reads an IPv4 datagram from the endpoint c, copying the
datagram into b. It returns the received datagram as the IPv4
header h, the payload p and the control message cm.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetBPF">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=6514:6574#L245">SetBPF</a>
					<a class="permalink" href="index.html#RawConn.SetBPF">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetBPF(filter []<a href="../bpf/index.html">bpf</a>.<a href="../bpf/index.html#RawInstruction">RawInstruction</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetBPF attaches a BPF program to the connection.
</p>
<p>
Only supported on Linux.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetControlMessage">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=3342:3409#L114">SetControlMessage</a>
					<a class="permalink" href="index.html#RawConn.SetControlMessage">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetControlMessage(cf <a href="index.html#ControlFlags">ControlFlags</a>, on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetControlMessage sets the per packet IP-level socket options.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetDeadline">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=3628:3676#L123">SetDeadline</a>
					<a class="permalink" href="index.html#RawConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline sets the read and write deadlines associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetICMPFilter">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=6223:6276#L231">SetICMPFilter</a>
					<a class="permalink" href="index.html#RawConn.SetICMPFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetICMPFilter(f *<a href="index.html#ICMPFilter">ICMPFilter</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetICMPFilter deploys the ICMP filter.
Currently only Linux supports this.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetMulticastInterface">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=1231:1297#L44">SetMulticastInterface</a>
					<a class="permalink" href="index.html#RawConn.SetMulticastInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetMulticastInterface(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastInterface sets the default interface for future
multicast packet transmissions.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetMulticastLoopback">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=1993:2047#L74">SetMulticastLoopback</a>
					<a class="permalink" href="index.html#RawConn.SetMulticastLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetMulticastLoopback(on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastLoopback sets whether transmitted multicast packets
should be copied and send back to the originator.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetMulticastTTL">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/dgramopt.go?s=600:649#L18">SetMulticastTTL</a>
					<a class="permalink" href="index.html#RawConn.SetMulticastTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetMulticastTTL(ttl <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastTTL sets the time-to-live field value for future
outgoing multicast packets.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetReadDeadline">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=3858:3910#L132">SetReadDeadline</a>
					<a class="permalink" href="index.html#RawConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetReadDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline sets the read deadline associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetTOS">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=505:547#L11">SetTOS</a>
					<a class="permalink" href="index.html#RawConn.SetTOS">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetTOS(tos <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTOS sets the type-of-service field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetTTL">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=1015:1057#L36">SetTTL</a>
					<a class="permalink" href="index.html#RawConn.SetTTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetTTL(ttl <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTTL sets the time-to-live field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="RawConn.SetWriteDeadline">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=4098:4151#L141">SetWriteDeadline</a>
					<a class="permalink" href="index.html#RawConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) SetWriteDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline sets the write deadline associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="RawConn.TOS">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=243:282#L1">TOS</a>
					<a class="permalink" href="index.html#RawConn.TOS">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) TOS() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TOS returns the type-of-service field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="RawConn.TTL">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/genericopt.go?s=756:795#L23">TTL</a>
					<a class="permalink" href="index.html#RawConn.TTL">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) TTL() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TTL returns the time-to-live field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="RawConn.WriteBatch">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=5030:5102#L160">WriteBatch</a>
					<a class="permalink" href="index.html#RawConn.WriteBatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) WriteBatch(ms []<a href="index.html#Message">Message</a>, flags <a href="http://localhost:6060/pkg/builtin/#int">int</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteBatch writes a batch of messages.
</p>
<p>
The provided flags is a set of platform-dependent flags, such as
syscall.MSG_DONTROUTE.
</p>
<p>
It returns the number of messages written on a successful write.
</p>
<p>
On Linux, a batch write will be optimized.
On other platforms, this method will write only a single message.
</p>

				
				
				
			
				
				<h3 id="RawConn.WriteTo">func (*RawConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv4/packet.go?s=2063:2141#L53">WriteTo</a>
					<a class="permalink" href="index.html#RawConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#RawConn">RawConn</a>) WriteTo(h *<a href="index.html#Header">Header</a>, p []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>, cm *<a href="index.html#ControlMessage">ControlMessage</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
WriteTo writes an IPv4 datagram through the endpoint c, copying the
datagram from the IPv4 header h and the payload p. The control
message cm allows the datagram path and the outgoing interface to be
specified.  Currently only Darwin and Linux support this. The cm
may be nil if control of the outgoing datagram is not required.
</p>
<p>
The IPv4 header h must contain appropriate fields that include:
</p>
<pre>Version       = &lt;must be specified&gt;
Len           = &lt;must be specified&gt;
TOS           = &lt;must be specified&gt;
TotalLen      = &lt;must be specified&gt;
ID            = platform sets an appropriate value if ID is zero
FragOff       = &lt;must be specified&gt;
TTL           = &lt;must be specified&gt;
Protocol      = &lt;must be specified&gt;
Checksum      = platform sets an appropriate value if Checksum is zero
Src           = platform sets an appropriate value if Src is nil
Dst           = &lt;must be specified&gt;
Options       = optional
</pre>

				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=258:359#L6" style="float: left;">&#x261e;</a> <p>
On Windows, the ReadBatch and WriteBatch methods of
PacketConn are not implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv4/batch.go?s=361:459#L9" style="float: left;">&#x261e;</a> <p>
On Windows, the ReadBatch and WriteBatch methods of
RawConn are not implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv4/doc.go?s=7894:7972#L234" style="float: left;">&#x261e;</a> <p>
This package is not implemented on AIX, JS, NaCl and
Plan 9.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv4/endpoint.go?s=238:441#L4" style="float: left;">&#x261e;</a> <p>
On Windows, the JoinSourceSpecificGroup,
LeaveSourceSpecificGroup, ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup methods of PacketConn and RawConn are
not implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv4/packet.go?s=230:324#L3" style="float: left;">&#x261e;</a> <p>
On Windows, the ReadFrom and WriteTo methods of RawConn
are not implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv4/payload.go?s=230:345#L3" style="float: left;">&#x261e;</a> <p>
On Windows, the ControlMessage for ReadFrom and WriteTo
methods of PacketConn is not implemented.
</p>
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.11.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6060/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

</body>
</html>

