<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ipv6 - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../../../../lib/godoc/style.css">


<script>window.initFuncs = [];</script>

<script src="../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.11.5";</script>
<script src="../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/">Go</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">
<a href="http://localhost:6060/doc/">Documents</a>
<a href="../../../../index.html">Packages</a>
<a href="http://localhost:6060/project/">The Project</a>
<a href="http://localhost:6060/help/">Help</a>

<a href="http://localhost:6060/blog/">Blog</a>


<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ipv6
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/net/ipv6"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package ipv6 implements IP-level socket options for the Internet
Protocol version 6.
</p>
<p>
The package provides IP-level socket options that allow
manipulation of IPv6 facilities.
</p>
<p>
The IPv6 protocol is defined in RFC 8200.
Socket interface extensions are defined in RFC 3493, RFC 3542 and
RFC 3678.
MLDv1 and MLDv2 are defined in RFC 2710 and RFC 3810.
Source-specific multicast is defined in RFC 4607.
</p>
<p>
On Darwin, this package requires OS X Mavericks version 10.9 or
above, or equivalent.
</p>
<h3 id="hdr-Unicasting">Unicasting</h3>
<p>
The options for unicasting are available for net.TCPConn,
net.UDPConn and net.IPConn which are created as network connections
that use the IPv6 transport. When a single TCP connection carrying
a data flow of multiple packets needs to indicate the flow is
important, Conn is used to set the traffic class field on the IPv6
header for each packet.
</p>
<pre>ln, err := net.Listen(&#34;tcp6&#34;, &#34;[::]:1024&#34;)
if err != nil {
	// error handling
}
defer ln.Close()
for {
	c, err := ln.Accept()
	if err != nil {
		// error handling
	}
	go func(c net.Conn) {
		defer c.Close()
</pre>
<p>
The outgoing packets will be labeled DiffServ assured forwarding
class 1 low drop precedence, known as AF11 packets.
</p>
<pre>		if err := ipv6.NewConn(c).SetTrafficClass(0x28); err != nil {
			// error handling
		}
		if _, err := c.Write(data); err != nil {
			// error handling
		}
	}(c)
}
</pre>
<h3 id="hdr-Multicasting">Multicasting</h3>
<p>
The options for multicasting are available for net.UDPConn and
net.IPConn which are created as network connections that use the
IPv6 transport. A few network facilities must be prepared before
you begin multicasting, at a minimum joining network interfaces and
multicast groups.
</p>
<pre>en0, err := net.InterfaceByName(&#34;en0&#34;)
if err != nil {
	// error handling
}
en1, err := net.InterfaceByIndex(911)
if err != nil {
	// error handling
}
group := net.ParseIP(&#34;ff02::114&#34;)
</pre>
<p>
First, an application listens to an appropriate address with an
appropriate service port.
</p>
<pre>c, err := net.ListenPacket(&#34;udp6&#34;, &#34;[::]:1024&#34;)
if err != nil {
	// error handling
}
defer c.Close()
</pre>
<p>
Second, the application joins multicast groups, starts listening to
the groups on the specified network interfaces. Note that the
service port for transport layer protocol does not matter with this
operation as joining groups affects only network and link layer
protocols, such as IPv6 and Ethernet.
</p>
<pre>p := ipv6.NewPacketConn(c)
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: group}); err != nil {
	// error handling
}
if err := p.JoinGroup(en1, &amp;net.UDPAddr{IP: group}); err != nil {
	// error handling
}
</pre>
<p>
The application might set per packet control message transmissions
between the protocol stack within the kernel. When the application
needs a destination address on an incoming packet,
SetControlMessage of PacketConn is used to enable control message
transmissions.
</p>
<pre>if err := p.SetControlMessage(ipv6.FlagDst, true); err != nil {
	// error handling
}
</pre>
<p>
The application could identify whether the received packets are
of interest by using the control message that contains the
destination address of the received packet.
</p>
<pre>b := make([]byte, 1500)
for {
	n, rcm, src, err := p.ReadFrom(b)
	if err != nil {
		// error handling
	}
	if rcm.Dst.IsMulticast() {
		if rcm.Dst.Equal(group) {
			// joined group, do something
		} else {
			// unknown group, discard
			continue
		}
	}
</pre>
<p>
The application can also send both unicast and multicast packets.
</p>
<pre>	p.SetTrafficClass(0x0)
	p.SetHopLimit(16)
	if _, err := p.WriteTo(data[:n], nil, src); err != nil {
		// error handling
	}
	dst := &amp;net.UDPAddr{IP: group, Port: 1024}
	wcm := ipv6.ControlMessage{TrafficClass: 0xe0, HopLimit: 1}
	for _, ifi := range []*net.Interface{en0, en1} {
		wcm.IfIndex = ifi.Index
		if _, err := p.WriteTo(data[:n], &amp;wcm, dst); err != nil {
			// error handling
		}
	}
}
</pre>
<h3 id="hdr-More_multicasting">More multicasting</h3>
<p>
An application that uses PacketConn may join multiple multicast
groups. For example, a UDP listener with port 1024 might join two
different groups across over two different network interfaces by
using:
</p>
<pre>c, err := net.ListenPacket(&#34;udp6&#34;, &#34;[::]:1024&#34;)
if err != nil {
	// error handling
}
defer c.Close()
p := ipv6.NewPacketConn(c)
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff02::1:114&#34;)}); err != nil {
	// error handling
}
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff02::2:114&#34;)}); err != nil {
	// error handling
}
if err := p.JoinGroup(en1, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff02::2:114&#34;)}); err != nil {
	// error handling
}
</pre>
<p>
It is possible for multiple UDP listeners that listen on the same
UDP port to join the same multicast group. The net package will
provide a socket that listens to a wildcard address with reusable
UDP port when an appropriate multicast address prefix is passed to
the net.ListenPacket or net.ListenUDP.
</p>
<pre>c1, err := net.ListenPacket(&#34;udp6&#34;, &#34;[ff02::]:1024&#34;)
if err != nil {
	// error handling
}
defer c1.Close()
c2, err := net.ListenPacket(&#34;udp6&#34;, &#34;[ff02::]:1024&#34;)
if err != nil {
	// error handling
}
defer c2.Close()
p1 := ipv6.NewPacketConn(c1)
if err := p1.JoinGroup(en0, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff02::114&#34;)}); err != nil {
	// error handling
}
p2 := ipv6.NewPacketConn(c2)
if err := p2.JoinGroup(en0, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff02::114&#34;)}); err != nil {
	// error handling
}
</pre>
<p>
Also it is possible for the application to leave or rejoin a
multicast group on the network interface.
</p>
<pre>if err := p.LeaveGroup(en0, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff02::114&#34;)}); err != nil {
	// error handling
}
if err := p.JoinGroup(en0, &amp;net.UDPAddr{IP: net.ParseIP(&#34;ff01::114&#34;)}); err != nil {
	// error handling
}
</pre>
<h3 id="hdr-Source_specific_multicasting">Source-specific multicasting</h3>
<p>
An application that uses PacketConn on MLDv2 supported platform is
able to join source-specific multicast groups.
The application may use JoinSourceSpecificGroup and
LeaveSourceSpecificGroup for the operation known as &#34;include&#34; mode,
</p>
<pre>ssmgroup := net.UDPAddr{IP: net.ParseIP(&#34;ff32::8000:9&#34;)}
ssmsource := net.UDPAddr{IP: net.ParseIP(&#34;fe80::cafe&#34;)}
if err := p.JoinSourceSpecificGroup(en0, &amp;ssmgroup, &amp;ssmsource); err != nil {
	// error handling
}
if err := p.LeaveSourceSpecificGroup(en0, &amp;ssmgroup, &amp;ssmsource); err != nil {
	// error handling
}
</pre>
<p>
or JoinGroup, ExcludeSourceSpecificGroup,
IncludeSourceSpecificGroup and LeaveGroup for the operation known
as &#34;exclude&#34; mode.
</p>
<pre>exclsource := net.UDPAddr{IP: net.ParseIP(&#34;fe80::dead&#34;)}
if err := p.JoinGroup(en0, &amp;ssmgroup); err != nil {
	// error handling
}
if err := p.ExcludeSourceSpecificGroup(en0, &amp;ssmgroup, &amp;exclsource); err != nil {
	// error handling
}
if err := p.LeaveGroup(en0, &amp;ssmgroup); err != nil {
	// error handling
}
</pre>
<p>
Note that it depends on each platform implementation what happens
when an application which runs on MLDv2 unsupported platform uses
JoinSourceSpecificGroup and LeaveSourceSpecificGroup.
In general the platform tries to fall back to conversations using
MLDv1 and starts to listen to multicast traffic.
In the fallback case, ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup may return an error.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="index.html#NewControlMessage">func NewControlMessage(cf ControlFlags) []byte</a></dd>
			
			
				
				<dd><a href="index.html#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewConn">func NewConn(c net.Conn) *Conn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.HopLimit">func (c *Conn) HopLimit() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.PathMTU">func (c *Conn) PathMTU() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetHopLimit">func (c *Conn) SetHopLimit(hoplim int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.SetTrafficClass">func (c *Conn) SetTrafficClass(tclass int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Conn.TrafficClass">func (c *Conn) TrafficClass() (int, error)</a></dd>
				
			
				
				<dd><a href="index.html#ControlFlags">type ControlFlags</a></dd>
				
				
			
				
				<dd><a href="index.html#ControlMessage">type ControlMessage</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ControlMessage.Marshal">func (cm *ControlMessage) Marshal() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ControlMessage.Parse">func (cm *ControlMessage) Parse(b []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ControlMessage.String">func (cm *ControlMessage) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Header">type Header</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ParseHeader">func ParseHeader(b []byte) (*Header, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#Header.String">func (h *Header) String() string</a></dd>
				
			
				
				<dd><a href="index.html#ICMPFilter">type ICMPFilter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.Accept">func (f *ICMPFilter) Accept(typ ICMPType)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.Block">func (f *ICMPFilter) Block(typ ICMPType)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.SetAll">func (f *ICMPFilter) SetAll(block bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPFilter.WillBlock">func (f *ICMPFilter) WillBlock(typ ICMPType) bool</a></dd>
				
			
				
				<dd><a href="index.html#ICMPType">type ICMPType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPType.Protocol">func (typ ICMPType) Protocol() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ICMPType.String">func (typ ICMPType) String() string</a></dd>
				
			
				
				<dd><a href="index.html#Message">type Message</a></dd>
				
				
			
				
				<dd><a href="index.html#PacketConn">type PacketConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewPacketConn">func NewPacketConn(c net.PacketConn) *PacketConn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.Checksum">func (c *PacketConn) Checksum() (on bool, offset int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.Close">func (c *PacketConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ExcludeSourceSpecificGroup">func (c *PacketConn) ExcludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.HopLimit">func (c *PacketConn) HopLimit() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ICMPFilter">func (c *PacketConn) ICMPFilter() (*ICMPFilter, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.IncludeSourceSpecificGroup">func (c *PacketConn) IncludeSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.JoinGroup">func (c *PacketConn) JoinGroup(ifi *net.Interface, group net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.JoinSourceSpecificGroup">func (c *PacketConn) JoinSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.LeaveGroup">func (c *PacketConn) LeaveGroup(ifi *net.Interface, group net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.LeaveSourceSpecificGroup">func (c *PacketConn) LeaveSourceSpecificGroup(ifi *net.Interface, group, source net.Addr) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.MulticastHopLimit">func (c *PacketConn) MulticastHopLimit() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.MulticastInterface">func (c *PacketConn) MulticastInterface() (*net.Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.MulticastLoopback">func (c *PacketConn) MulticastLoopback() (bool, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ReadBatch">func (c *PacketConn) ReadBatch(ms []Message, flags int) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.ReadFrom">func (c *PacketConn) ReadFrom(b []byte) (n int, cm *ControlMessage, src net.Addr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetBPF">func (c *PacketConn) SetBPF(filter []bpf.RawInstruction) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetChecksum">func (c *PacketConn) SetChecksum(on bool, offset int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetControlMessage">func (c *PacketConn) SetControlMessage(cf ControlFlags, on bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetDeadline">func (c *PacketConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetHopLimit">func (c *PacketConn) SetHopLimit(hoplim int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetICMPFilter">func (c *PacketConn) SetICMPFilter(f *ICMPFilter) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetMulticastHopLimit">func (c *PacketConn) SetMulticastHopLimit(hoplim int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetMulticastInterface">func (c *PacketConn) SetMulticastInterface(ifi *net.Interface) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetMulticastLoopback">func (c *PacketConn) SetMulticastLoopback(on bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetReadDeadline">func (c *PacketConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetTrafficClass">func (c *PacketConn) SetTrafficClass(tclass int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.SetWriteDeadline">func (c *PacketConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.TrafficClass">func (c *PacketConn) TrafficClass() (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.WriteBatch">func (c *PacketConn) WriteBatch(ms []Message, flags int) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#PacketConn.WriteTo">func (c *PacketConn) WriteTo(b []byte, cm *ControlMessage, dst net.Addr) (n int, err error)</a></dd>
				
			
			
				
				<dd><a href="index.html#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_Conn_markingTCP">Conn (MarkingTCP)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_PacketConn_advertisingOSPFHello">PacketConn (AdvertisingOSPFHello)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_PacketConn_servingOneShotMulticastDNS">PacketConn (ServingOneShotMulticastDNS)</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_PacketConn_tracingIPPacketRoute">PacketConn (TracingIPPacketRoute)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/batch.go">batch.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go">control.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/control_rfc3542_unix.go">control_rfc3542_unix.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/control_unix.go">control_unix.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go">dgramopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/doc.go">doc.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go">endpoint.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go">genericopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/header.go">header.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/helper.go">helper.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/iana.go">iana.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go">icmp.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp_linux.go">icmp_linux.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/payload.go">payload.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/payload_cmsg.go">payload_cmsg.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/payload_cmsg_go1_9.go">payload_cmsg_go1_9.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/sockopt.go">sockopt.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/sockopt_posix.go">sockopt_posix.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/sys_asmreq.go">sys_asmreq.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/sys_bpf.go">sys_bpf.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/sys_linux.go">sys_linux.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/sys_ssmreq.go">sys_ssmreq.go</a>
			
				<a href="http://localhost:6060/src/golang.org/x/net/ipv6/zsys_linux_amd64.go">zsys_linux_amd64.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span id="Version">Version</span>   = 6  <span class="comment">// protocol version</span>
    <span id="HeaderLen">HeaderLen</span> = 40 <span class="comment">// header length</span>
)</pre>
			
		
		
		
			
			
			<h2 id="NewControlMessage">func <a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go?s=4816:4862#L139">NewControlMessage</a>
				<a class="permalink" href="index.html#NewControlMessage">&#xb6;</a>
				
				
			</h2>
			<pre>func NewControlMessage(cf <a href="index.html#ControlFlags">ControlFlags</a>) []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a></pre>
			<p>
NewControlMessage returns a new control message.
</p>
<p>
The returned message is large enough for options specified by cf.
</p>

			
			

		
		
			
			
			<h2 id="Conn">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=587:619#L12">Conn</a>
				<a class="permalink" href="index.html#Conn">&#xb6;</a>
				
				
			</h2>
			<p>
A Conn represents a network endpoint that uses IPv6 transport.
It allows to set basic IP-level socket options such as traffic
class and hop limit.
</p>

			<pre>type Conn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Conn_markingTCP" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (MarkingTCP)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (MarkingTCP)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
ln, err := net.Listen(&#34;tcp&#34;, &#34;[::]:1024&#34;)
if err != nil {
    log.Fatal(err)
}
defer ln.Close()

for {
    c, err := ln.Accept()
    if err != nil {
        log.Fatal(err)
    }
    go func(c net.Conn) {
        defer c.Close()
        if c.RemoteAddr().(*net.TCPAddr).IP.To16() != nil &amp;&amp; c.RemoteAddr().(*net.TCPAddr).IP.To4() == nil {
            p := ipv6.NewConn(c)
            if err := p.SetTrafficClass(0x28); err != nil { <span class="comment">// DSCP AF11</span>
                log.Fatal(err)
            }
            if err := p.SetHopLimit(128); err != nil {
                log.Fatal(err)
            }
        }
        if _, err := c.Write([]byte(&#34;HELLO-R-U-THERE-ACK&#34;)); err != nil {
            log.Fatal(err)
        }
    }(c)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewConn">func <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=1102:1132#L40">NewConn</a>
					<a class="permalink" href="index.html#NewConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConn(c <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Conn">Conn</a>) *<a href="index.html#Conn">Conn</a></pre>
				<p>
NewConn returns a new Conn.
</p>

				
				
			

			
				
				<h3 id="Conn.HopLimit">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=817:861#L24">HopLimit</a>
					<a class="permalink" href="index.html#Conn.HopLimit">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) HopLimit() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
HopLimit returns the hop limit field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="Conn.PathMTU">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=821:858#L24">PathMTU</a>
					<a class="permalink" href="index.html#Conn.PathMTU">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) PathMTU() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
PathMTU returns a path MTU value for the destination associated
with the endpoint.
</p>

				
				
				
			
				
				<h3 id="Conn.SetHopLimit">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=1088:1138#L37">SetHopLimit</a>
					<a class="permalink" href="index.html#Conn.SetHopLimit">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetHopLimit(hoplim <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetHopLimit sets the hop limit field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="Conn.SetTrafficClass">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=540:594#L12">SetTrafficClass</a>
					<a class="permalink" href="index.html#Conn.SetTrafficClass">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) SetTrafficClass(tclass <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTrafficClass sets the traffic class field value for future
outgoing packets.
</p>

				
				
				
			
				
				<h3 id="Conn.TrafficClass">func (*Conn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=253:301#L1">TrafficClass</a>
					<a class="permalink" href="index.html#Conn.TrafficClass">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#Conn">Conn</a>) TrafficClass() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TrafficClass returns the traffic class field value for outgoing
packets.
</p>

				
				
				
			
		
			
			
			<h2 id="ControlFlags">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go?s=878:900#L22">ControlFlags</a>
				<a class="permalink" href="index.html#ControlFlags">&#xb6;</a>
				
				
			</h2>
			<p>
A ControlFlags represents per packet basis IP-level socket option
control flags.
</p>

			<pre>type ControlFlags <a href="http://localhost:6060/pkg/builtin/#uint">uint</a></pre>

			
				
				<pre>const (
    <span id="FlagTrafficClass">FlagTrafficClass</span> <a href="index.html#ControlFlags">ControlFlags</a> = 1 &lt;&lt; <a href="http://localhost:6060/pkg/builtin/#iota">iota</a> <span class="comment">// pass the traffic class on the received packet</span>
    <span id="FlagHopLimit">FlagHopLimit</span>                              <span class="comment">// pass the hop limit on the received packet</span>
    <span id="FlagSrc">FlagSrc</span>                                   <span class="comment">// pass the source address on the received packet</span>
    <span id="FlagDst">FlagDst</span>                                   <span class="comment">// pass the destination address on the received packet</span>
    <span id="FlagInterface">FlagInterface</span>                             <span class="comment">// pass the interface index on the received packet</span>
    <span id="FlagPathMTU">FlagPathMTU</span>                               <span class="comment">// pass the path MTU on the received packet path</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="ControlMessage">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go?s=1594:2373#L37">ControlMessage</a>
				<a class="permalink" href="index.html#ControlMessage">&#xb6;</a>
				
				
			</h2>
			<p>
A ControlMessage represents per packet basis IP-level socket
options.
</p>

			<pre>type ControlMessage struct {
    <span class="comment">// Receiving socket options: SetControlMessage allows to</span>
    <span class="comment">// receive the options from the protocol stack using ReadFrom</span>
    <span class="comment">// method of PacketConn.</span>
    <span class="comment">//</span>
    <span class="comment">// Specifying socket options: ControlMessage for WriteTo</span>
    <span class="comment">// method of PacketConn allows to send the options to the</span>
    <span class="comment">// protocol stack.</span>
    <span class="comment">//</span>
<span id="ControlMessage.TrafficClass"></span>    TrafficClass <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// traffic class, must be 1 &lt;= value &lt;= 255 when specifying</span>
<span id="ControlMessage.HopLimit"></span>    HopLimit     <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// hop limit, must be 1 &lt;= value &lt;= 255 when specifying</span>
<span id="ControlMessage.Src"></span>    Src          <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// source address, specifying only</span>
<span id="ControlMessage.Dst"></span>    Dst          <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// destination address, receiving only</span>
<span id="ControlMessage.IfIndex"></span>    IfIndex      <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// interface index, must be 1 &lt;= value when specifying</span>
<span id="ControlMessage.NextHop"></span>    NextHop      <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// next hop address, specifying only</span>
<span id="ControlMessage.MTU"></span>    MTU          <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// path MTU, receiving only</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ControlMessage.Marshal">func (*ControlMessage) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go?s=2669:2711#L63">Marshal</a>
					<a class="permalink" href="index.html#ControlMessage.Marshal">&#xb6;</a>
					
					
				</h3>
				<pre>func (cm *<a href="index.html#ControlMessage">ControlMessage</a>) Marshal() []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a></pre>
				<p>
Marshal returns the binary encoding of cm.
</p>

				
				
				
			
				
				<h3 id="ControlMessage.Parse">func (*ControlMessage) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go?s=3882:3929#L109">Parse</a>
					<a class="permalink" href="index.html#ControlMessage.Parse">&#xb6;</a>
					
					
				</h3>
				<pre>func (cm *<a href="index.html#ControlMessage">ControlMessage</a>) Parse(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Parse parses b as a control message and stores the result in cm.
</p>

				
				
				
			
				
				<h3 id="ControlMessage.String">func (*ControlMessage) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/control.go?s=2375:2416#L55">String</a>
					<a class="permalink" href="index.html#ControlMessage.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (cm *<a href="index.html#ControlMessage">ControlMessage</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Header">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/header.go?s=343:671#L9">Header</a>
				<a class="permalink" href="index.html#Header">&#xb6;</a>
				
				
			</h2>
			<p>
A Header represents an IPv6 base header.
</p>

			<pre>type Header struct {
<span id="Header.Version"></span>    Version      <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// protocol version</span>
<span id="Header.TrafficClass"></span>    TrafficClass <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// traffic class</span>
<span id="Header.FlowLabel"></span>    FlowLabel    <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// flow label</span>
<span id="Header.PayloadLen"></span>    PayloadLen   <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// payload length</span>
<span id="Header.NextHeader"></span>    NextHeader   <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// next header</span>
<span id="Header.HopLimit"></span>    HopLimit     <a href="http://localhost:6060/pkg/builtin/#int">int</a>    <span class="comment">// hop limit</span>
<span id="Header.Src"></span>    Src          <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// source address</span>
<span id="Header.Dst"></span>    Dst          <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#IP">IP</a> <span class="comment">// destination address</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ParseHeader">func <a href="http://localhost:6060/src/golang.org/x/net/ipv6/header.go?s=989:1032#L28">ParseHeader</a>
					<a class="permalink" href="index.html#ParseHeader">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseHeader(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) (*<a href="index.html#Header">Header</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseHeader parses b as an IPv6 base header.
</p>

				
				
			

			
				
				<h3 id="Header.String">func (*Header) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/header.go?s=673:705#L20">String</a>
					<a class="permalink" href="index.html#Header.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="index.html#Header">Header</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ICMPFilter">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=1030:1070#L26">ICMPFilter</a>
				<a class="permalink" href="index.html#ICMPFilter">&#xb6;</a>
				
				
			</h2>
			<p>
An ICMPFilter represents an ICMP message filter for incoming
packets. The filter belongs to a packet delivery path on a host and
it cannot interact with forwarding packets or tunnel-outer packets.
</p>
<p>
Note: RFC 8200 defines a reasonable role model. A node means a
device that implements IP. A router means a node that forwards IP
packets not explicitly addressed to itself, and a host means a node
that is not a router.
</p>

			<pre>type ICMPFilter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ICMPFilter.Accept">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=1151:1192#L32">Accept</a>
					<a class="permalink" href="index.html#ICMPFilter.Accept">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) Accept(typ <a href="index.html#ICMPType">ICMPType</a>)</pre>
				<p>
Accept accepts incoming ICMP packets including the type field value
typ.
</p>

				
				
				
			
				
				<h3 id="ICMPFilter.Block">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=1290:1330#L38">Block</a>
					<a class="permalink" href="index.html#ICMPFilter.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) Block(typ <a href="index.html#ICMPType">ICMPType</a>)</pre>
				<p>
Block blocks incoming ICMP packets including the type field value
typ.
</p>

				
				
				
			
				
				<h3 id="ICMPFilter.SetAll">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=1398:1437#L43">SetAll</a>
					<a class="permalink" href="index.html#ICMPFilter.SetAll">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) SetAll(block <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetAll sets the filter action to the filter.
</p>

				
				
				
			
				
				<h3 id="ICMPFilter.WillBlock">func (*ICMPFilter) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=1520:1569#L48">WillBlock</a>
					<a class="permalink" href="index.html#ICMPFilter.WillBlock">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="index.html#ICMPFilter">ICMPFilter</a>) WillBlock(typ <a href="index.html#ICMPType">ICMPType</a>) <a href="http://localhost:6060/pkg/builtin/#bool">bool</a></pre>
				<p>
WillBlock reports whether the ICMP type will be blocked.
</p>

				
				
				
			
		
			
			
			<h2 id="ICMPType">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=347:364#L3">ICMPType</a>
				<a class="permalink" href="index.html#ICMPType">&#xb6;</a>
				
				
			</h2>
			<p>
An ICMPType represents a type of ICMP message.
</p>

			<pre>type ICMPType <a href="http://localhost:6060/pkg/builtin/#int">int</a></pre>

			
				<p>
Internet Control Message Protocol version 6 (ICMPv6) Parameters, Updated: 2018-03-09
</p>

				<pre>const (
    <span id="ICMPTypeDestinationUnreachable">ICMPTypeDestinationUnreachable</span>                <a href="index.html#ICMPType">ICMPType</a> = 1   <span class="comment">// Destination Unreachable</span>
    <span id="ICMPTypePacketTooBig">ICMPTypePacketTooBig</span>                          <a href="index.html#ICMPType">ICMPType</a> = 2   <span class="comment">// Packet Too Big</span>
    <span id="ICMPTypeTimeExceeded">ICMPTypeTimeExceeded</span>                          <a href="index.html#ICMPType">ICMPType</a> = 3   <span class="comment">// Time Exceeded</span>
    <span id="ICMPTypeParameterProblem">ICMPTypeParameterProblem</span>                      <a href="index.html#ICMPType">ICMPType</a> = 4   <span class="comment">// Parameter Problem</span>
    <span id="ICMPTypeEchoRequest">ICMPTypeEchoRequest</span>                           <a href="index.html#ICMPType">ICMPType</a> = 128 <span class="comment">// Echo Request</span>
    <span id="ICMPTypeEchoReply">ICMPTypeEchoReply</span>                             <a href="index.html#ICMPType">ICMPType</a> = 129 <span class="comment">// Echo Reply</span>
    <span id="ICMPTypeMulticastListenerQuery">ICMPTypeMulticastListenerQuery</span>                <a href="index.html#ICMPType">ICMPType</a> = 130 <span class="comment">// Multicast Listener Query</span>
    <span id="ICMPTypeMulticastListenerReport">ICMPTypeMulticastListenerReport</span>               <a href="index.html#ICMPType">ICMPType</a> = 131 <span class="comment">// Multicast Listener Report</span>
    <span id="ICMPTypeMulticastListenerDone">ICMPTypeMulticastListenerDone</span>                 <a href="index.html#ICMPType">ICMPType</a> = 132 <span class="comment">// Multicast Listener Done</span>
    <span id="ICMPTypeRouterSolicitation">ICMPTypeRouterSolicitation</span>                    <a href="index.html#ICMPType">ICMPType</a> = 133 <span class="comment">// Router Solicitation</span>
    <span id="ICMPTypeRouterAdvertisement">ICMPTypeRouterAdvertisement</span>                   <a href="index.html#ICMPType">ICMPType</a> = 134 <span class="comment">// Router Advertisement</span>
    <span id="ICMPTypeNeighborSolicitation">ICMPTypeNeighborSolicitation</span>                  <a href="index.html#ICMPType">ICMPType</a> = 135 <span class="comment">// Neighbor Solicitation</span>
    <span id="ICMPTypeNeighborAdvertisement">ICMPTypeNeighborAdvertisement</span>                 <a href="index.html#ICMPType">ICMPType</a> = 136 <span class="comment">// Neighbor Advertisement</span>
    <span id="ICMPTypeRedirect">ICMPTypeRedirect</span>                              <a href="index.html#ICMPType">ICMPType</a> = 137 <span class="comment">// Redirect Message</span>
    <span id="ICMPTypeRouterRenumbering">ICMPTypeRouterRenumbering</span>                     <a href="index.html#ICMPType">ICMPType</a> = 138 <span class="comment">// Router Renumbering</span>
    <span id="ICMPTypeNodeInformationQuery">ICMPTypeNodeInformationQuery</span>                  <a href="index.html#ICMPType">ICMPType</a> = 139 <span class="comment">// ICMP Node Information Query</span>
    <span id="ICMPTypeNodeInformationResponse">ICMPTypeNodeInformationResponse</span>               <a href="index.html#ICMPType">ICMPType</a> = 140 <span class="comment">// ICMP Node Information Response</span>
    <span id="ICMPTypeInverseNeighborDiscoverySolicitation">ICMPTypeInverseNeighborDiscoverySolicitation</span>  <a href="index.html#ICMPType">ICMPType</a> = 141 <span class="comment">// Inverse Neighbor Discovery Solicitation Message</span>
    <span id="ICMPTypeInverseNeighborDiscoveryAdvertisement">ICMPTypeInverseNeighborDiscoveryAdvertisement</span> <a href="index.html#ICMPType">ICMPType</a> = 142 <span class="comment">// Inverse Neighbor Discovery Advertisement Message</span>
    <span id="ICMPTypeVersion2MulticastListenerReport">ICMPTypeVersion2MulticastListenerReport</span>       <a href="index.html#ICMPType">ICMPType</a> = 143 <span class="comment">// Version 2 Multicast Listener Report</span>
    <span id="ICMPTypeHomeAgentAddressDiscoveryRequest">ICMPTypeHomeAgentAddressDiscoveryRequest</span>      <a href="index.html#ICMPType">ICMPType</a> = 144 <span class="comment">// Home Agent Address Discovery Request Message</span>
    <span id="ICMPTypeHomeAgentAddressDiscoveryReply">ICMPTypeHomeAgentAddressDiscoveryReply</span>        <a href="index.html#ICMPType">ICMPType</a> = 145 <span class="comment">// Home Agent Address Discovery Reply Message</span>
    <span id="ICMPTypeMobilePrefixSolicitation">ICMPTypeMobilePrefixSolicitation</span>              <a href="index.html#ICMPType">ICMPType</a> = 146 <span class="comment">// Mobile Prefix Solicitation</span>
    <span id="ICMPTypeMobilePrefixAdvertisement">ICMPTypeMobilePrefixAdvertisement</span>             <a href="index.html#ICMPType">ICMPType</a> = 147 <span class="comment">// Mobile Prefix Advertisement</span>
    <span id="ICMPTypeCertificationPathSolicitation">ICMPTypeCertificationPathSolicitation</span>         <a href="index.html#ICMPType">ICMPType</a> = 148 <span class="comment">// Certification Path Solicitation Message</span>
    <span id="ICMPTypeCertificationPathAdvertisement">ICMPTypeCertificationPathAdvertisement</span>        <a href="index.html#ICMPType">ICMPType</a> = 149 <span class="comment">// Certification Path Advertisement Message</span>
    <span id="ICMPTypeMulticastRouterAdvertisement">ICMPTypeMulticastRouterAdvertisement</span>          <a href="index.html#ICMPType">ICMPType</a> = 151 <span class="comment">// Multicast Router Advertisement</span>
    <span id="ICMPTypeMulticastRouterSolicitation">ICMPTypeMulticastRouterSolicitation</span>           <a href="index.html#ICMPType">ICMPType</a> = 152 <span class="comment">// Multicast Router Solicitation</span>
    <span id="ICMPTypeMulticastRouterTermination">ICMPTypeMulticastRouterTermination</span>            <a href="index.html#ICMPType">ICMPType</a> = 153 <span class="comment">// Multicast Router Termination</span>
    <span id="ICMPTypeFMIPv6">ICMPTypeFMIPv6</span>                                <a href="index.html#ICMPType">ICMPType</a> = 154 <span class="comment">// FMIPv6 Messages</span>
    <span id="ICMPTypeRPLControl">ICMPTypeRPLControl</span>                            <a href="index.html#ICMPType">ICMPType</a> = 155 <span class="comment">// RPL Control Message</span>
    <span id="ICMPTypeILNPv6LocatorUpdate">ICMPTypeILNPv6LocatorUpdate</span>                   <a href="index.html#ICMPType">ICMPType</a> = 156 <span class="comment">// ILNPv6 Locator Update Message</span>
    <span id="ICMPTypeDuplicateAddressRequest">ICMPTypeDuplicateAddressRequest</span>               <a href="index.html#ICMPType">ICMPType</a> = 157 <span class="comment">// Duplicate Address Request</span>
    <span id="ICMPTypeDuplicateAddressConfirmation">ICMPTypeDuplicateAddressConfirmation</span>          <a href="index.html#ICMPType">ICMPType</a> = 158 <span class="comment">// Duplicate Address Confirmation</span>
    <span id="ICMPTypeMPLControl">ICMPTypeMPLControl</span>                            <a href="index.html#ICMPType">ICMPType</a> = 159 <span class="comment">// MPL Control Message</span>
    <span id="ICMPTypeExtendedEchoRequest">ICMPTypeExtendedEchoRequest</span>                   <a href="index.html#ICMPType">ICMPType</a> = 160 <span class="comment">// Extended Echo Request</span>
    <span id="ICMPTypeExtendedEchoReply">ICMPTypeExtendedEchoReply</span>                     <a href="index.html#ICMPType">ICMPType</a> = 161 <span class="comment">// Extended Echo Reply</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="ICMPType.Protocol">func (ICMPType) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=520:554#L14">Protocol</a>
					<a class="permalink" href="index.html#ICMPType.Protocol">&#xb6;</a>
					
					
				</h3>
				<pre>func (typ <a href="index.html#ICMPType">ICMPType</a>) Protocol() <a href="http://localhost:6060/pkg/builtin/#int">int</a></pre>
				<p>
Protocol returns the ICMPv6 protocol number.
</p>

				
				
				
			
				
				<h3 id="ICMPType.String">func (ICMPType) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=366:401#L5">String</a>
					<a class="permalink" href="index.html#ICMPType.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (typ <a href="index.html#ICMPType">ICMPType</a>) String() <a href="http://localhost:6060/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Message">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/batch.go?s=1526:1555#L45">Message</a>
				<a class="permalink" href="index.html#Message">&#xb6;</a>
				
				
			</h2>
			<p>
A Message represents an IO message.
</p>
<pre>type Message struct {
	Buffers [][]byte
	OOB     []byte
	Addr    net.Addr
	N       int
	NN      int
	Flags   int
}
</pre>
<p>
The Buffers fields represents a list of contiguous buffers, which
can be used for vectored IO, for example, putting a header and a
payload in each slice.
When writing, the Buffers field must contain at least one byte to
write.
When reading, the Buffers field will always contain a byte to read.
</p>
<p>
The OOB field contains protocol-specific control or miscellaneous
ancillary data known as out-of-band data.
It can be nil when not required.
</p>
<p>
The Addr field specifies a destination address when writing.
It can be nil when the underlying protocol of the endpoint uses
connection-oriented communication.
After a successful read, it may contain the source address on the
received packet.
</p>
<p>
The N field indicates the number of bytes read or written from/to
Buffers.
</p>
<p>
The NN field indicates the number of bytes read or written from/to
OOB.
</p>
<p>
The Flags field contains protocol-specific information on the
received message.
</p>

			<pre>type Message = <a href="../internal/socket/index.html">socket</a>.<a href="../internal/socket/index.html#Message">Message</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="PacketConn">type <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=1529:1593#L52">PacketConn</a>
				<a class="permalink" href="index.html#PacketConn">&#xb6;</a>
				
				
			</h2>
			<p>
A PacketConn represents a packet network endpoint that uses IPv6
transport. It is used to control several IP-level socket options
including IPv6 header manipulation. It also provides datagram
based network I/O methods specific to the IPv6 and higher layer
protocols such as OSPF, GRE, and UDP.
</p>

			<pre>type PacketConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_PacketConn_advertisingOSPFHello" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (AdvertisingOSPFHello)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (AdvertisingOSPFHello)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
c, err := net.ListenPacket(&#34;ip6:89&#34;, &#34;::&#34;) <span class="comment">// OSPF for IPv6</span>
if err != nil {
    log.Fatal(err)
}
defer c.Close()
p := ipv6.NewPacketConn(c)

en0, err := net.InterfaceByName(&#34;en0&#34;)
if err != nil {
    log.Fatal(err)
}
allSPFRouters := net.IPAddr{IP: net.ParseIP(&#34;ff02::5&#34;)}
if err := p.JoinGroup(en0, &amp;allSPFRouters); err != nil {
    log.Fatal(err)
}
defer p.LeaveGroup(en0, &amp;allSPFRouters)

hello := make([]byte, 24) <span class="comment">// fake hello data, you need to implement this</span>
ospf := make([]byte, 16)  <span class="comment">// fake ospf header, you need to implement this</span>
ospf[0] = 3               <span class="comment">// version 3</span>
ospf[1] = 1               <span class="comment">// hello packet</span>
ospf = append(ospf, hello...)
if err := p.SetChecksum(true, 12); err != nil {
    log.Fatal(err)
}

cm := ipv6.ControlMessage{
    TrafficClass: 0xc0, <span class="comment">// DSCP CS6</span>
    HopLimit:     1,
    IfIndex:      en0.Index,
}
if _, err := p.WriteTo(ospf, &amp;cm, &amp;allSPFRouters); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>
<div id="example_PacketConn_servingOneShotMulticastDNS" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (ServingOneShotMulticastDNS)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (ServingOneShotMulticastDNS)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
c, err := net.ListenPacket(&#34;udp6&#34;, &#34;[::]:5353&#34;) <span class="comment">// mDNS over UDP</span>
if err != nil {
    log.Fatal(err)
}
defer c.Close()
p := ipv6.NewPacketConn(c)

en0, err := net.InterfaceByName(&#34;en0&#34;)
if err != nil {
    log.Fatal(err)
}
mDNSLinkLocal := net.UDPAddr{IP: net.ParseIP(&#34;ff02::fb&#34;)}
if err := p.JoinGroup(en0, &amp;mDNSLinkLocal); err != nil {
    log.Fatal(err)
}
defer p.LeaveGroup(en0, &amp;mDNSLinkLocal)
if err := p.SetControlMessage(ipv6.FlagDst|ipv6.FlagInterface, true); err != nil {
    log.Fatal(err)
}

var wcm ipv6.ControlMessage
b := make([]byte, 1500)
for {
    _, rcm, peer, err := p.ReadFrom(b)
    if err != nil {
        log.Fatal(err)
    }
    if !rcm.Dst.IsMulticast() || !rcm.Dst.Equal(mDNSLinkLocal.IP) {
        continue
    }
    wcm.IfIndex = rcm.IfIndex
    answers := []byte(&#34;FAKE-MDNS-ANSWERS&#34;) <span class="comment">// fake mDNS answers, you need to implement this</span>
    if _, err := p.WriteTo(answers, &amp;wcm, peer); err != nil {
        log.Fatal(err)
    }
}
</pre>
			
		
	</div>
</div>
<div id="example_PacketConn_tracingIPPacketRoute" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (TracingIPPacketRoute)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (TracingIPPacketRoute)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Tracing an IP packet route to www.google.com.</span>

const host = &#34;www.google.com&#34;
ips, err := net.LookupIP(host)
if err != nil {
    log.Fatal(err)
}
var dst net.IPAddr
for _, ip := range ips {
    if ip.To16() != nil &amp;&amp; ip.To4() == nil {
        dst.IP = ip
        fmt.Printf(&#34;using %v for tracing an IP packet route to %s\n&#34;, dst.IP, host)
        break
    }
}
if dst.IP == nil {
    log.Fatal(&#34;no AAAA record found&#34;)
}

c, err := net.ListenPacket(&#34;ip6:58&#34;, &#34;::&#34;) <span class="comment">// ICMP for IPv6</span>
if err != nil {
    log.Fatal(err)
}
defer c.Close()
p := ipv6.NewPacketConn(c)

if err := p.SetControlMessage(ipv6.FlagHopLimit|ipv6.FlagSrc|ipv6.FlagDst|ipv6.FlagInterface, true); err != nil {
    log.Fatal(err)
}
wm := icmp.Message{
    Type: ipv6.ICMPTypeEchoRequest, Code: 0,
    Body: &amp;icmp.Echo{
        ID:   os.Getpid() &amp; 0xffff,
        Data: []byte(&#34;HELLO-R-U-THERE&#34;),
    },
}
var f ipv6.ICMPFilter
f.SetAll(true)
f.Accept(ipv6.ICMPTypeTimeExceeded)
f.Accept(ipv6.ICMPTypeEchoReply)
if err := p.SetICMPFilter(&amp;f); err != nil {
    log.Fatal(err)
}

var wcm ipv6.ControlMessage
rb := make([]byte, 1500)
for i := 1; i &lt;= 64; i++ { <span class="comment">// up to 64 hops</span>
    wm.Body.(*icmp.Echo).Seq = i
    wb, err := wm.Marshal(nil)
    if err != nil {
        log.Fatal(err)
    }

    <span class="comment">// In the real world usually there are several</span>
    <span class="comment">// multiple traffic-engineered paths for each hop.</span>
    <span class="comment">// You may need to probe a few times to each hop.</span>
    begin := time.Now()
    wcm.HopLimit = i
    if _, err := p.WriteTo(wb, &amp;wcm, &amp;dst); err != nil {
        log.Fatal(err)
    }
    if err := p.SetReadDeadline(time.Now().Add(3 * time.Second)); err != nil {
        log.Fatal(err)
    }
    n, rcm, peer, err := p.ReadFrom(rb)
    if err != nil {
        if err, ok := err.(net.Error); ok &amp;&amp; err.Timeout() {
            fmt.Printf(&#34;%v\t*\n&#34;, i)
            continue
        }
        log.Fatal(err)
    }
    rm, err := icmp.ParseMessage(58, rb[:n])
    if err != nil {
        log.Fatal(err)
    }
    rtt := time.Since(begin)

    <span class="comment">// In the real world you need to determine whether the</span>
    <span class="comment">// received message is yours using ControlMessage.Src,</span>
    <span class="comment">// ControlMesage.Dst, icmp.Echo.ID and icmp.Echo.Seq.</span>
    switch rm.Type {
    case ipv6.ICMPTypeTimeExceeded:
        names, _ := net.LookupAddr(peer.String())
        fmt.Printf(&#34;%d\t%v %+v %v\n\t%+v\n&#34;, i, peer, names, rtt, rcm)
    case ipv6.ICMPTypeEchoReply:
        names, _ := net.LookupAddr(peer.String())
        fmt.Printf(&#34;%d\t%v %+v %v\n\t%+v\n&#34;, i, peer, names, rtt, rcm)
        return
    }
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewPacketConn">func <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=2951:2999#L110">NewPacketConn</a>
					<a class="permalink" href="index.html#NewPacketConn">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPacketConn(c <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#PacketConn">PacketConn</a>) *<a href="index.html#PacketConn">PacketConn</a></pre>
				<p>
NewPacketConn returns a new PacketConn using c as its underlying
transport.
</p>

				
				
			

			
				
				<h3 id="PacketConn.Checksum">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=6119:6181#L220">Checksum</a>
					<a class="permalink" href="index.html#PacketConn.Checksum">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) Checksum() (on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, offset <a href="http://localhost:6060/pkg/builtin/#int">int</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
Checksum reports whether the kernel will compute, store or verify a
checksum for both incoming and outgoing packets. If on is true, it
returns an offset in bytes into the data of where the checksum
field is located.
</p>

				
				
				
			
				
				<h3 id="PacketConn.Close">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=2740:2774#L101">Close</a>
					<a class="permalink" href="index.html#PacketConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) Close() <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
Close closes the endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ExcludeSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=4910:5005#L176">ExcludeSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.ExcludeSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ExcludeSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
ExcludeSourceSpecificGroup excludes the source-specific group from
the already joined any-source groups by JoinGroup on the interface
ifi.
</p>

				
				
				
			
				
				<h3 id="PacketConn.HopLimit">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=817:861#L24">HopLimit</a>
					<a class="permalink" href="index.html#PacketConn.HopLimit">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) HopLimit() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
HopLimit returns the hop limit field value for outgoing packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ICMPFilter">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=6906:6958#L256">ICMPFilter</a>
					<a class="permalink" href="index.html#PacketConn.ICMPFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ICMPFilter() (*<a href="index.html#ICMPFilter">ICMPFilter</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ICMPFilter returns an ICMP filter.
</p>

				
				
				
			
				
				<h3 id="PacketConn.IncludeSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=5467:5562#L197">IncludeSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.IncludeSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) IncludeSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
IncludeSourceSpecificGroup includes the excluded source-specific
group by ExcludeSourceSpecificGroup again on the interface ifi.
</p>

				
				
				
			
				
				<h3 id="PacketConn.JoinGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=2741:2811#L94">JoinGroup</a>
					<a class="permalink" href="index.html#PacketConn.JoinGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) JoinGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
JoinGroup joins the group address group on the interface ifi.
By default all sources that can cast data to group are accepted.
It&#39;s possible to mute and unmute data transmission from a specific
source by using ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup.
JoinGroup uses the system assigned multicast interface when ifi is
nil, although this is not recommended because the assignment
depends on platforms and sometimes it might require routing
configuration.
</p>

				
				
				
			
				
				<h3 id="PacketConn.JoinSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=3838:3930#L133">JoinSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.JoinSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) JoinSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
JoinSourceSpecificGroup joins the source-specific group comprising
group and source on the interface ifi.
JoinSourceSpecificGroup uses the system assigned multicast
interface when ifi is nil, although this is not recommended because
the assignment depends on platforms and sometimes it might require
routing configuration.
</p>

				
				
				
			
				
				<h3 id="PacketConn.LeaveGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=3193:3264#L112">LeaveGroup</a>
					<a class="permalink" href="index.html#PacketConn.LeaveGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) LeaveGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
LeaveGroup leaves the group address group on the interface ifi
regardless of whether the group is any-source group or
source-specific group.
</p>

				
				
				
			
				
				<h3 id="PacketConn.LeaveSourceSpecificGroup">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=4342:4435#L154">LeaveSourceSpecificGroup</a>
					<a class="permalink" href="index.html#PacketConn.LeaveSourceSpecificGroup">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) LeaveSourceSpecificGroup(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, group, source <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
LeaveSourceSpecificGroup leaves the source-specific group on the
interface ifi.
</p>

				
				
				
			
				
				<h3 id="PacketConn.MulticastHopLimit">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=308:359#L5">MulticastHopLimit</a>
					<a class="permalink" href="index.html#PacketConn.MulticastHopLimit">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) MulticastHopLimit() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastHopLimit returns the hop limit field value for outgoing
multicast packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.MulticastInterface">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=922:985#L31">MulticastInterface</a>
					<a class="permalink" href="index.html#PacketConn.MulticastInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) MulticastInterface() (*<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastInterface returns the default interface for multicast
packet transmissions.
</p>

				
				
				
			
				
				<h3 id="PacketConn.MulticastLoopback">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=1620:1672#L57">MulticastLoopback</a>
					<a class="permalink" href="index.html#PacketConn.MulticastLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) MulticastLoopback() (<a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
MulticastLoopback reports whether transmitted multicast packets
should be copied and send back to the originator.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ReadBatch">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/batch.go?s=1894:1966#L57">ReadBatch</a>
					<a class="permalink" href="index.html#PacketConn.ReadBatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ReadBatch(ms []<a href="index.html#Message">Message</a>, flags <a href="http://localhost:6060/pkg/builtin/#int">int</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadBatch reads a batch of messages.
</p>
<p>
The provided flags is a set of platform-dependent flags, such as
syscall.MSG_PEEK.
</p>
<p>
On a successful read it returns the number of messages received, up
to len(ms).
</p>
<p>
On Linux, a batch read will be optimized.
On other platforms, this method will read only a single message.
</p>

				
				
				
			
				
				<h3 id="PacketConn.ReadFrom">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/payload_cmsg.go?s=492:588#L5">ReadFrom</a>
					<a class="permalink" href="index.html#PacketConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) ReadFrom(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>) (n <a href="http://localhost:6060/pkg/builtin/#int">int</a>, cm *<a href="index.html#ControlMessage">ControlMessage</a>, src <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
ReadFrom reads a payload of the received IPv6 datagram, from the
endpoint c, copying the payload into b. It returns the number of
bytes copied into b, the control message cm and the source address
src of the received datagram.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetBPF">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=7453:7513#L282">SetBPF</a>
					<a class="permalink" href="index.html#PacketConn.SetBPF">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetBPF(filter []<a href="../bpf/index.html">bpf</a>.<a href="../bpf/index.html#RawInstruction">RawInstruction</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetBPF attaches a BPF program to the connection.
</p>
<p>
Only supported on Linux.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetChecksum">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=6633:6690#L241">SetChecksum</a>
					<a class="permalink" href="index.html#PacketConn.SetChecksum">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetChecksum(on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>, offset <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetChecksum enables the kernel checksum processing. If on is ture,
the offset should be an offset in bytes into the data of where the
checksum field is located.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetControlMessage">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=1790:1860#L66">SetControlMessage</a>
					<a class="permalink" href="index.html#PacketConn.SetControlMessage">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetControlMessage(cf <a href="index.html#ControlFlags">ControlFlags</a>, on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetControlMessage allows to receive the per packet basis IP-level
socket options.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetDeadline">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=2081:2132#L75">SetDeadline</a>
					<a class="permalink" href="index.html#PacketConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetDeadline sets the read and write deadlines associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetHopLimit">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=1088:1138#L37">SetHopLimit</a>
					<a class="permalink" href="index.html#PacketConn.SetHopLimit">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetHopLimit(hoplim <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetHopLimit sets the hop limit field value for future outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetICMPFilter">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=7162:7215#L268">SetICMPFilter</a>
					<a class="permalink" href="index.html#PacketConn.SetICMPFilter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetICMPFilter(f *<a href="index.html#ICMPFilter">ICMPFilter</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetICMPFilter deploys the ICMP filter.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetMulticastHopLimit">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=614:671#L18">SetMulticastHopLimit</a>
					<a class="permalink" href="index.html#PacketConn.SetMulticastHopLimit">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetMulticastHopLimit(hoplim <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastHopLimit sets the hop limit field value for future
outgoing multicast packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetMulticastInterface">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=1261:1327#L44">SetMulticastInterface</a>
					<a class="permalink" href="index.html#PacketConn.SetMulticastInterface">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetMulticastInterface(ifi *<a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Interface">Interface</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastInterface sets the default interface for future
multicast packet transmissions.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetMulticastLoopback">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/dgramopt.go?s=2023:2077#L74">SetMulticastLoopback</a>
					<a class="permalink" href="index.html#PacketConn.SetMulticastLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetMulticastLoopback(on <a href="http://localhost:6060/pkg/builtin/#bool">bool</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetMulticastLoopback sets whether transmitted multicast packets
should be copied and send back to the originator.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetReadDeadline">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=2309:2364#L84">SetReadDeadline</a>
					<a class="permalink" href="index.html#PacketConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetReadDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetReadDeadline sets the read deadline associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetTrafficClass">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=540:594#L12">SetTrafficClass</a>
					<a class="permalink" href="index.html#PacketConn.SetTrafficClass">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetTrafficClass(tclass <a href="http://localhost:6060/pkg/builtin/#int">int</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetTrafficClass sets the traffic class field value for future
outgoing packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.SetWriteDeadline">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=2547:2603#L93">SetWriteDeadline</a>
					<a class="permalink" href="index.html#PacketConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) SetWriteDeadline(t <a href="http://localhost:6060/pkg/time/">time</a>.<a href="http://localhost:6060/pkg/time/#Time">Time</a>) <a href="http://localhost:6060/pkg/builtin/#error">error</a></pre>
				<p>
SetWriteDeadline sets the write deadline associated with the
endpoint.
</p>

				
				
				
			
				
				<h3 id="PacketConn.TrafficClass">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/genericopt.go?s=253:301#L1">TrafficClass</a>
					<a class="permalink" href="index.html#PacketConn.TrafficClass">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) TrafficClass() (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
TrafficClass returns the traffic class field value for outgoing
packets.
</p>

				
				
				
			
				
				<h3 id="PacketConn.WriteBatch">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/batch.go?s=2813:2886#L88">WriteBatch</a>
					<a class="permalink" href="index.html#PacketConn.WriteBatch">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) WriteBatch(ms []<a href="index.html#Message">Message</a>, flags <a href="http://localhost:6060/pkg/builtin/#int">int</a>) (<a href="http://localhost:6060/pkg/builtin/#int">int</a>, <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteBatch writes a batch of messages.
</p>
<p>
The provided flags is a set of platform-dependent flags, such as
syscall.MSG_DONTROUTE.
</p>
<p>
It returns the number of messages written on a successful write.
</p>
<p>
On Linux, a batch write will be optimized.
On other platforms, this method will write only a single message.
</p>

				
				
				
			
				
				<h3 id="PacketConn.WriteTo">func (*PacketConn) <a href="http://localhost:6060/src/golang.org/x/net/ipv6/payload_cmsg.go?s=1018:1113#L17">WriteTo</a>
					<a class="permalink" href="index.html#PacketConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#PacketConn">PacketConn</a>) WriteTo(b []<a href="http://localhost:6060/pkg/builtin/#byte">byte</a>, cm *<a href="index.html#ControlMessage">ControlMessage</a>, dst <a href="http://localhost:6060/pkg/net/">net</a>.<a href="http://localhost:6060/pkg/net/#Addr">Addr</a>) (n <a href="http://localhost:6060/pkg/builtin/#int">int</a>, err <a href="http://localhost:6060/pkg/builtin/#error">error</a>)</pre>
				<p>
WriteTo writes a payload of the IPv6 datagram, to the destination
address dst through the endpoint c, copying the payload from b. It
returns the number of bytes written. The control message cm allows
the IPv6 header fields and the datagram path to be specified. The
cm may be nil if control of the outgoing datagram is not required.
</p>

				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv6/batch.go?s=258:359#L6" style="float: left;">&#x261e;</a> <p>
On Windows, the ReadBatch and WriteBatch methods of
PacketConn are not implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv6/doc.go?s=7832:7910#L233" style="float: left;">&#x261e;</a> <p>
This package is not implemented on AIX, JS, NaCl and
Plan 9.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv6/endpoint.go?s=238:429#L4" style="float: left;">&#x261e;</a> <p>
On Windows, the JoinSourceSpecificGroup,
LeaveSourceSpecificGroup, ExcludeSourceSpecificGroup and
IncludeSourceSpecificGroup methods of PacketConn are not
implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv6/icmp.go?s=215:295#L1" style="float: left;">&#x261e;</a> <p>
On Windows, methods related to ICMPFilter are not
implemented.
</p>
</li>
			
			<li><a href="http://localhost:6060/src/golang.org/x/net/ipv6/payload.go?s=230:345#L3" style="float: left;">&#x261e;</a> <p>
On Windows, the ControlMessage for ReadFrom and WriteTo
methods of PacketConn is not implemented.
</p>
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.11.5.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br>
<a href="http://localhost:6060/doc/tos.html">Terms of Service</a> |
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

</body>
</html>

